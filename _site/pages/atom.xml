<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>禹墨的博客</title>
    <link>http://disheng54.github.io</link>
    <description>禹墨的博客</description>
    
      <item>
        <title>8-String to Integer</title>
        <link>http://disheng54.github.io/2016/08/25/leetcode-6-StringToInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/25/leetcode-6-StringToInteger.html</guid>
        <pubDate>Thu, 25 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;

&lt;p&gt;Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;

&lt;p&gt;Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.&lt;/p&gt;

&lt;p&gt;Requirements for atoi:&lt;br /&gt;
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;

&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;

&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;

&lt;p&gt;If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;实现方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;atoi&lt;/code&gt; 将一个字符串转换为整数&lt;br /&gt;
提示：请考虑到所有输入的情况。如果你想要挑战一下自己，就可以不用开下面的注意事项然后问题自己，都有哪些输入情况。&lt;br /&gt;
注意：这道题目的定义是模糊的(没有给输入的限定条件)，你需要自己考虑所有的输入情况。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;atoi &lt;/code&gt; 方法的要求：&lt;br /&gt;
该方法要求忽略字符串开始的空白字符，一直到第一个非空白字符为止。然后从这个字符开始，先判断初始的正负字符，然后选取尽可能多的数字字符，并将它们转换为一个数值。&lt;br /&gt;
也许该字符串的有效数字后面还有一些额外的非数字字符，那么将忽略这些字符。&lt;br /&gt;
如果第一个非空白字符不是数字字符，或者改字符串是个空串，或者只包含空白字符，则不执行转换。&lt;br /&gt;
如果未执行有效的转换，就返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; .如果转换后的数字超出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 类型标识数字的的范围，那么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道题目比较简单，正如题目的里面的讲的那样，难点是要考虑到各种的情况。&lt;br /&gt;
1、空字符串、空白字符串、没有有效数字的字符串，返回0&lt;br /&gt;
2、需要去除前面的无效空白字符。&lt;br /&gt;
3、考虑第一个非空字符，如果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 标识正值，如果是&lt;code class=&quot;highlighter-rouge&quot;&gt; -&lt;/code&gt; 标识负值。&lt;br /&gt;
4、忽略有效数字字符后面的所有无效字符，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;   -123&amp;amp;456&#39; &lt;/code&gt;转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;-123&lt;/code&gt;&lt;br /&gt;
5、如果转换后的整数值，超过了返回就返回返回&lt;code class=&quot;highlighter-rouge&quot;&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/22/16.
 */
public class Atoi_8 {
    public static int myAtoi(String str) {
        if (str == null ||str.trim().length() == 0){
            return  0;
        }

        int index = 0;
        while ((index &amp;lt; str.length()) &amp;amp;&amp;amp; (str.charAt(index) == &#39; &#39;)){
            index ++;

        }

        int sign = 1;
        if (str.charAt(index) == &#39;+&#39;){
            sign = 1;
            index ++;
        }else if (str.charAt(index) == &#39;-&#39;){
            sign = -1;
            index ++;
        }

        long result = 0L;
        for (int i = index; i &amp;lt; str.length(); i++){
           if( str.charAt(i) &amp;gt;=  &#39;0&#39; &amp;amp;&amp;amp; str.charAt(i) &amp;lt;= &#39;9&#39;){
                result = result * 10 + (str.charAt(i) - &#39;0&#39;);
               if (sign == 1){
                   if(result &amp;gt; Integer.MAX_VALUE){
                       result = Integer.MAX_VALUE;
                       break;
                   }
               }else{
                   if (result*sign &amp;lt; Integer.MIN_VALUE){
                       result = Integer.MIN_VALUE;
                       break;
                   }
               }
           }else{
               break;
           }
        }

        return (int)result * sign;
    }

    public static void main(String[] args) {
        //String str = &quot;  -214748364734dd&quot;;
        String str = &quot;  -00134&quot;;
        long startTime = System.nanoTime();
        int result = myAtoi(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>7-Reverse Integer</title>
        <link>http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</guid>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Have you thought about this?&lt;br /&gt;
Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;

&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;

&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;反转一个整数数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：在编码之前有一些问题需要考虑，如果你已经考虑了这些问题，这将是你的加分点。&lt;br /&gt;
如果该整数的最后一位是0，那么僵该输出什么呢？比如 10， 100&lt;br /&gt;
反转后的整数也许会产生溢出，假定输入的是一个32位的整数，如果反转&lt;code class=&quot;highlighter-rouge&quot;&gt;1000000003&lt;/code&gt;将产生溢出，那这种情况该如何处理呢？&lt;br /&gt;
如果发生了溢出，就直接返回为0.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;需要考虑三个方面的问题。&lt;br /&gt;
1. 需要考虑负数的反转。&lt;br /&gt;
2. 如果整数的末尾是0，比如10， 100， 那么反转后为1， 1&lt;br /&gt;
3. 如果反转后产生了溢出，那么就直接返回 0&lt;/p&gt;

&lt;p&gt;解决思路为：&lt;br /&gt;
定义一个long 类型的变量result，来存储反转后的整数&lt;br /&gt;
然后循环反转,注意负数的问题，同时检测到发生了溢出，就返回0&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/17/16.
 * 反正整形字符串
 */
public class ReverseInteger_7 {
    public static int reverse(int x) {
        long result = 0;
        while (x != 0){
            result = result * 10 + x % 10;
            x = x / 10;

            if (result &amp;gt; Integer.MAX_VALUE || result &amp;lt; Integer.MIN_VALUE){
                result = 0;
                break;
            }
        }

        return (int)result;
    }

    public static void main(String[] args) {
        int x  = 1000000003;
        long startTime = System.nanoTime();
        int result = reverse(x);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>6-ZigZag Conversion</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/&quot;&gt;6. ZigZag Conversion&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;The string &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then read line by line: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;br /&gt;
Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string convert(string text, int nRows);&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; should return &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;将字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt;按照给定的行数，转为成锯齿形的字符串。然后将该锯齿形字符串一次读成&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编写代码将给定的字符串和行数，将字符串进行锯齿转换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string convert(string text, int nRows);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;如果nRows = 1， 那么直接返回。&lt;br /&gt;
如果nRows = 2, 转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PYAIHRNAPLSIIG&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P	 Y	 A	 I	 H	 R	 N
A	 P	 L	 S	 I	 I	 G
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果 nRows = 3  转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PAHNAPLSIIGYIR&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果 nRows = 4 转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PINALSIGYAHRPI&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 			I			N
A		L	S		I	G
Y	A		H	R
P			I
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过上面可以总结出一个规律，第一行和最后一行两个数据的间距为: &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * nRows -2 &lt;/code&gt;&lt;br /&gt;
中间第 i 行，第1列和它临近字符的间距为: &lt;code class=&quot;highlighter-rouge&quot;&gt;2*nRows -2 - 2 * i&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/16/16.
 */
public class ZigZag_6 {

    public static String convert(String s, int numRows){
        if (numRows &amp;lt;= 1 || s == null || s.length() == 0){
            return s;
        }

        StringBuilder sb = new StringBuilder();
        int size = 2 * numRows -2;
        for (int i = 0; i &amp;lt; numRows; i++){
            for (int j = i; j &amp;lt; s.length();j+= size){
                sb.append(s.charAt(j));
                if (i != 0 &amp;amp;&amp;amp; i != numRows -1){
                    int temp = j + size - 2 * i;
                    if (temp &amp;lt; s.length()){
                        sb.append(s.charAt(temp));
                    }
                }
            }
        }

        return sb.toString();
    }

    public static void main(String[] args) {
       // String str = &quot;PAYPALISHIRING&quot;;
        String str = &quot;A&quot;;
        int nRows = 1;
        long startTime = System.nanoTime();
        String zigZag = convert(str, nRows);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;ZigZag:&quot; + zigZag + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>5-Longest Palindromic Substring</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;给定一个字符串 S，找出其中最长的回文子串。假定 S的最长长度为1000，且存在唯一的最长回文子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个题目可以利用动态规划的方法进行处理。&lt;br /&gt;
假定字符串的长度为len, 声明一个二维数组：dp = new boolean[len][len]&lt;br /&gt;
dp[i][j] 标识字符串S 中S[i~j]的子串是不是回文字符串。&lt;br /&gt;
判断S[i~j]如果是回文串，必须满足两个条件：&lt;br /&gt;
1. S[i] = S[j] &lt;br /&gt;
2. dp[i+1][j-1] = true。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wks on 8/8/16.
 */
public class LongestPalindrome_5 {
    /**
     * 利用动态规划的方法.
     * @param s
     * @return
     */
    public static String longestPalindrome(String s){
        if (s == null || s.length() == 1) {
            return s;
        }

        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int begin = 0, end = 0, max = 1;

        for (int i = len - 1; i &amp;gt;= 0; i--){
            for (int j = i; j &amp;lt; len; j++){
                if (s.charAt(i) == s.charAt(j)){
                    if (j - i &amp;lt;= 2 ||  (dp[i+1][j-1] &amp;amp;&amp;amp; j-1 &amp;gt; 0)){
                        dp[i][j] = true;
                        if (max &amp;lt; j - i + 1){
                            max = j - i + 1;
                            begin = i;
                            end = j;
                        }
                    }
                }
            }
        }


        return s.substring(begin, end+1);
    }

    public static void main(String[] args) {
        String str = &quot;1aba12&quot;;
        long startTime = System.nanoTime();
        String palindrome = longestPalindrome(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;palindrome:&quot; + palindrome + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>4-Median of Two Sorted Arrays</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br /&gt;
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The median is 2.0&lt;br /&gt;
Example 2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The median is (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;有两个排序且长度分别为m和n的数组nums1 和 nums2。找出这两个排序的中间值。&lt;br /&gt;
要求运行时间为O(log(m+n))&lt;/p&gt;

&lt;p&gt;示例1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中位值为： 2.0&lt;br /&gt;
示例2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中位值： (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;题目的意思是将两个数组合并后，如果是奇数个，就返回中间的那个值，如果是偶数个，就返回中间两个数的平均值&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;合并的解决的方式&lt;/p&gt;

    &lt;p&gt;首先想到的时候合并的方式解决，其原理就是合并两个数组，算出中位值，其运行时间为O((m+n)/2) .&lt;br /&gt;
 但是不能满足题目运行时间要求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式解决&lt;/p&gt;

    &lt;p&gt;这种方式是在讨论区发现的。具体实现的原理：寻找数组中第 k(k=（m+n）/ 2+1)个最小的数字.&lt;br /&gt;
 将nums1[k] 和 nums2[k] 进行比较，会有三种情况：&lt;br /&gt;
 如果nums1[k] == nums2[k] 那么这个值就是要找的值。&lt;br /&gt;
 如果nums1[k] &amp;lt; nums2[k],那么第k个数值，必定出现在nums1[ (k+1) ~ m ] 和 nums2[ 0 ~ (k - 1)] 区间中&lt;br /&gt;
 如果nums1[k] &amp;gt; nums2[k],那么第k个数值，必定出现在nums1[ 0 ~ (k - 1)] 和 nums2[ (k+1) ~ n ] 区间中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/7/16.
 */
public class MedianTwoSortedArrays_4 {

    /**
     * 通过合并的方式进行字符串处理.
     */
    public static double findMedianSortedArraysByMerge(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;
        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        int num = 0, firstNum = 0;
        int n1 = 0, n2 = 0, index = 1;
        while (true){
            if (n1 &amp;lt; nums1.length){
                if (n2 &amp;lt; nums2.length){
                    if(nums1[n1] &amp;gt; nums2[n2]){
                        num = nums2[n2++];
                    }else{
                        num = nums1[n1++];
                    }
                }else{
                    num = nums1[n1++];
                }
            }else{
                num = nums2[n2++];
            }

            if (index == leftMedian &amp;amp;&amp;amp; rightMedian == leftMedian){
                return num;
            }else if (index == leftMedian &amp;amp;&amp;amp; rightMedian != leftMedian){
                firstNum = num;
            }else if (index == rightMedian){
                return (firstNum + num)/2.0;
            }

            index++;
        }
    }

    /**
     * 通过递归的方式实现.
     * @param nums1
     * @param nums2
     * @return
     */
    public static double findMedianSortedArraysByRecursive(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;

        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        if (rightMedian != leftMedian){
            return (getMedianNum(nums1,0,nums2,0,leftMedian)+ getMedianNum(nums1,0,nums2,0,rightMedian))/2.0;
        }else{
            return getMedianNum(nums1,0,nums2,0,leftMedian);
        }
    }

    public static double getMedianNum(int[] nums1, int start1, int[]nums2, int start2, int index){
        if(start1 &amp;gt; nums1.length-1) return nums2[start2+index-1];
        if(start2 &amp;gt; nums2.length-1) return nums1[start1+index-1];
        if(index == 1) return Math.min(nums1[start1],nums2[start2]);

        if(start2+index/2-1 &amp;gt; nums2.length-1){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        } 
        if(start1+index/2-1 &amp;gt; nums1.length-1){
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        } 

        if(nums1[start1+index/2-1] &amp;lt; nums2[start2+index/2-1]){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        }else{
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        }
    }

    public static void main(String[] args){
        int[] nums1 = {1,3};
        int[] nums2 = {2};

//        int[] nums1 = {1,3};
//        int[] nums2 = {2};
        long startTime = System.nanoTime();
        double median = findMedianSortedArraysByMerge(nums1, nums2);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
        
        startTime = System.nanoTime();
        median = findMedianSortedArraysByRecursive(nums1, nums2);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>3-Longest Substring Without Repeating Characters</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abcabcbb&quot;&lt;/code&gt;, the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abc&quot;&lt;/code&gt;, which the length is 3.&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;bbbbb&quot;,&lt;/code&gt; the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;b&quot;&lt;/code&gt;, with the length of 1.&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwwkew&quot;&lt;/code&gt;, the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;wke&quot;&lt;/code&gt;, with the length of 3. Note that the answer must be a substring, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwke&quot;&lt;/code&gt; is a subsequence and not a substring.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;获取一个字符串的各个字符都不相同的子串的最大长度。&lt;br /&gt;
举例：&lt;/p&gt;

&lt;p&gt;字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abcabcbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abc&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;bbbbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;b&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwwkew&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;wke&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;. &lt;br /&gt;
注意结果必须为连续的子串， 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwke&quot;&lt;/code&gt;是不同的字符组合，但不是连续的子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;首先要明白这道题目是要获取字符串中不同字符字符组成的子串的最大长度，而不是不同字符的个数。&lt;br /&gt;
声明一个变量start,记录不同字符串的初始索引，一个变量mxlen 记录最大程度，然后遍历字串中字符，记录该字符的索引index，并且查询该字符上次出现的索引位置，如果该字符存在上次索引LastIndex，并且该索引值不小于 start，那么将index 减去 start当做该不同字符子串的长度与maxlen，比较取其大着。通过将LastIndex赋值与start。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 8/6/16.
 * 获取字符串中不重复的字字符串的最大长度.
 */
public class LongSubNoRepeatCHar_3 {

    public static int lengthOfLongestSubstringByMap(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            if (map.get(s.charAt(i)) != null){
                int j = map.get(s.charAt(i));
                if (j &amp;gt;= start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = j + 1;
                    map.remove(s.charAt(i));
                }
            }

            map.put(s.charAt(i), i);
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static int lengthOfLongestSubstringByArray(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        int[] chars = new int[256];
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            int ch = s.charAt(i);
            if (chars[ch] != 0){
                if (chars[ch] &amp;gt; start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = chars[ch];
                }
            }

            chars[ch] = i + 1;
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static void main(String[] args){
        //String str = &quot;abcabcbb&quot;;
        //String str = &quot;aaa&quot;;
        //String str = &quot;pwwkew&quot;;
        // String str = &quot;au&quot;;
        String str = &quot;aab&quot;;
        long startTime = System.nanoTime();
        int length = lengthOfLongestSubstringByMap(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);

        startTime = System.nanoTime();
        length = lengthOfLongestSubstringByArray(str);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by yumodev on 8/6/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() == 0) {
            return 0;
        }

        int chars[128];
        memset(chars, 0xff, 128 * sizeof(int));
        int maxLen = 1;
        int start = 0;
        for (int i = 0; i &amp;lt; s.size(); ++i) {
            if (chars[s[i]] != 0 &amp;amp;&amp;amp; chars[s[i]] &amp;gt; start) {
//                if(i - start &amp;gt; maxLen){
//                    maxLen = i - start;
//                }

                maxLen = i - start &amp;gt; maxLen ? i - start : maxLen;
                start = chars[s[i]];
            }

            chars[s[i]] = i + 1;
        }

        if (s.length() - start &amp;gt; maxLen) {
            maxLen = s.length() - start;
        }

        return maxLen;
    }
};

int main() {
   // string str = &quot;auu&quot;;
    string str = &quot;dvdf&quot;;
    //string str = &quot;aaa&quot;;
    //string str = &quot;pwwkew&quot;;
    // string str = &quot;au&quot;;
    //string str = &quot;aab&quot;;
    clock_t start, finish;
    Solution su;
    start = clock();
    int len = su.lengthOfLongestSubstring(str);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot;  len &quot; &amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-javascript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  if (s === undefined || s.length === 0) {
   return 0;
 }
 var chars = {};
 var maxLen = 1;
 var start = 0;
 for(i = 0; i &amp;lt; s.length; i++){
   if (chars[s[i]] !== undefined) {
      if (chars[s[i]] &amp;gt;= start) {
        if(i - start &amp;gt; maxLen){
          maxLen = i - start;
        }
        start = chars[s[i]];
      }
   }

   chars[s[i]] = i + 1;
 }

 if(s.length - start &amp;gt; maxLen){
   maxLen = s.length - start;
 }

 return maxLen;
};
//var str = &quot;auu&quot;;
var str = &quot;dvdf&quot;
var len = lengthOfLongestSubstring(str);
console.log(num+&quot; &quot;+len);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>2-Add Two Numbers</title>
        <link>http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</guid>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;题目原地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给出两个标识非负整数的链表，整数在链表中反向存储且链表中的每个节点只存储一个数字。&lt;br /&gt;
将两个整数链表相加，将结果用链表返回&lt;br /&gt;
输入: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
输出: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个简单的问题，只是稍微注意下两个链表长度不一致就可以了。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wks on 8/5/16.
 * You are given two linked lists representing two non-negative numbers.
 * The digits are stored in reverse order and each of their nodes contain a single digit.
 * Add the two numbers and return it as a linked list.
 * &amp;lt;p&amp;gt;
 * Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
 * Output: 7 -&amp;gt; 0 -&amp;gt; 8
 */
public class AddTwoNumbers_2 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int lso = 0;
        int sum = 0;
        ListNode ls = null;
        ListNode nextLn = null;
        while (l1 != null || l2 != null || lso != 0) {
            sum = lso;
            if (l1 != null) sum += l1.val;
            if (l2 != null) sum += l2.val;

            lso = sum / 10;
            ListNode temp = new ListNode(sum % 10);
            if (ls == null) nextLn = ls = temp;
            else{
                nextLn.next = temp;
                nextLn = nextLn.next;
            }

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return ls;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(1027633061);
        ListNode l2 = initListNode(1696698036);
//
//        ListNode l1 = initListNode(342);
//        ListNode l2 = initListNode(465);

//        ListNode l1 = initListNode(5);
//        ListNode l2 = initListNode(5);
        System.out.println(&quot;listNode1 &quot; + ListNodeToString(l1));

        System.out.println(&quot;listNode2 &quot; + ListNodeToString(l2));

        ListNode ls = addTwoNumbers(l1, l2);
        System.out.println(&quot;listNodes &quot; + ListNodeToString(ls));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by yumo on 8/5/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;

struct ListNode
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) { }
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int lso = 0;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while (true){
            int sum = lso;
            if(l1 != NULL){
                sum += l1-&amp;gt;val;
                l1 = l1-&amp;gt;next;
            }
            if(l2 != NULL){
                sum += l2-&amp;gt;val;
                l2 = l2-&amp;gt;next;
            }
            lso = sum /10;
            ListNode* node = new ListNode(sum %10);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }

            if(l1 == NULL &amp;amp;&amp;amp; l2 == NULL &amp;amp;&amp;amp; lso == 0){
                break;
            }
        }

        return ln;
    }

    ListNode* initListNode(int num){
        int mod = 0;
        int temp = num;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while(num  &amp;gt; 0){
            mod = num % 10;
            num = num / 10;
            ListNode* node = new ListNode(mod);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }
        }
        return ln;
    }

    string listNodeToString(ListNode *ln){
        ListNode* next = ln;
        string sb;
        while(next != NULL){
            int val = next-&amp;gt;val;
            next = next-&amp;gt;next;
            sb += to_string(val)+&quot; &quot;;
        }
        return sb;
    }
};

int main()
{
//     int num1 = 342;
//     int num2 = 465;

//    int num1 = 5;
//    int num2 = 5;

      int num1 = 1027633061;
      int num2 = 1696698036;
     Solution solution;

     ListNode* l1 = solution.initListNode(num1);
     ListNode* l2 = solution.initListNode(num2);

     cout&amp;lt;&amp;lt;&quot;l1 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l1)&amp;lt;&amp;lt;endl;
     cout&amp;lt;&amp;lt;&quot;l2 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l2)&amp;lt;&amp;lt;endl;


    clock_t start, finish;

    start = clock();
    ListNode* ln = solution.addTwoNumbers(l1, l2);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot; &amp;lt;&amp;lt; ((double) (finish - start) / CLOCKS_PER_SEC) * 1000000 &amp;lt;&amp;lt;&quot;result: &quot;&amp;lt;&amp;lt;solution.listNodeToString(ln) &amp;lt;&amp;lt; endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-JavaScript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ListNode(val) {
     this.val = val;
     this.next = null;
}

function initListNode(num){
   var mod = 0;
   var ln = null;
   var nextLn = null;
   while(num &amp;gt; 0){
      mod = num % 10;
      num = parseInt(num / 10);
      if(ln == null){
        ln = new ListNode(mod);
        nextLn = ln;
      }else{
        nextLn.next = new ListNode(mod);
        nextLn = nextLn.next;
      }
   }

   return ln;
}

function listNodeToString(ln){
  var str =&quot;&quot;;
  var next = ln;
  while(next != null){
    str += next.val+&quot; &quot;;
    next = next.next;
  }
  return str;
}

var addTwoNumbers = function(l1, l2) {
    var los = 0;
    var ln = null;
    var nextLn = null;
    while(true){
      var sum = los;
      if(l1 != null){
        sum += l1.val;
        l1 = l1.next;
      }

      if(l2 != null){
        sum += l2.val;
        l2 = l2.next;
      }
      if(ln == null){
        nextLn = ln = new ListNode(sum % 10);
      }else{
        nextLn.next = new ListNode(sum % 10);
        nextLn = nextLn.next;
      }

      los = parseInt(sum / 10);
      if(l1 == null &amp;amp;&amp;amp; l2 == null &amp;amp;&amp;amp; los == 0){
         break;
      }
    }

    return ln;
};

// var num1 = 342;
// var num2 = 465;

var num1 = 5;
var num2 = 5;

// var num1 = 342;
// var num2 = 465;

var l1 = initListNode(num1);
var l2 = initListNode(num2);
console.log(&quot;l1:&quot;+listNodeToString(l1));
console.log(&quot;l2:&quot;+listNodeToString(l2));
var ln = addTwoNumbers(l1, l2);
console.log(&quot;result:&quot;+listNodeToString(ln));

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Ubuntu 安装 Tomcat</title>
        <link>http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</guid>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;jdk&quot;&gt;安装JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从官网下载JDK，下载路径 http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.tar.gz&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;jdk-8u101-linux-x64.tar.gz&lt;/code&gt; 移动到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt; 中， 解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/jvm &lt;/code&gt;目录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir jvm
sudo tar -zxvf jdk-8u101-linux-x64.tar.gz -C /usr/lib/jvm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jre&quot;&gt;配置JRE路径&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开环境变量文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vi ~/.bashrc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在文件的末尾添加下面内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_101
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jre-1&quot;&gt;测试JRE&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;java -version&lt;/code&gt;  查看当前的Java路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java version &quot;1.8.0_101&quot;
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;安装tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载tomcat 下载地址：http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M9/bin/apache-tomcat-9.0.0.M9.zip&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将文件移动到 /usr/local 目录下，解压命名为 tomcat9&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cp apache-tomcat-9.0.0.M9.zip /usr/local
  uzip apache-tomcat-9.0.0.M9.zip
  mv apache-tomcat-9.0.0.M9 tomcat9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;启动tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;开启tomcat9 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chomd 755 /usr/local/tomcat9/bin/*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;启动tomcat&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/tomcat9/bin
./startup.sh

Using CATALINA_BASE:   /usr/local/tomcat9
Using CATALINA_HOME:   /usr/local/tomcat9
Using CATALINA_TMPDIR: /usr/local/tomcat9/temp
Using JRE_HOME:        /usr/lib/jvm/jdk1.8.0_101/jre
Using CLASSPATH:       /usr/local/tomcat9/bin/bootstrap.jar:/usr/local/tomcat9/bin/tomcat-juli.jar
Tomcat started.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;测试访问&lt;/h3&gt;

&lt;p&gt;在浏览器中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt; 访问&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>比较两个字符串排序后是否相等</title>
        <link>http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;比较两个字符串排序后是否相等&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;首先比较字符串的长度，长度不相等的字符串，即使排序后也是不相等。&lt;br /&gt;
如果两个字符串长度相符，那么有下面两种方法进行比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让两个字符串分别排序后进行比较&lt;/li&gt;
  &lt;li&gt;比较两个字符串中的每个字符的数量是否相等
    &lt;ol&gt;
      &lt;li&gt;将字符和字符的数量当做Map的key和value，然后分别比较。&lt;/li&gt;
      &lt;li&gt;如果字符串是Ascii编码，那么可以将字符的数量直接放到数组进行优化。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例(Java)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 比较两个字符排序后是否相等
 */
public class StringIsSameAfterSort {


    private static String sort(String str){
        char[] chArr = str.toCharArray();
        Arrays.sort(chArr);
        return new String(chArr);
    }

    /**
     * 通过Arrays.sort进行比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByArraysSort(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        return sort(str1).equals(sort(str2));
    }

    private static Map convertMapNums(String str){
        Map&amp;lt;Character, Integer&amp;gt; map= new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;  str.length(); i++){
            char c = str.charAt(i);
            if (map.get(c) == null){
                map.put(c,  1);
            }else{
                map.put(c,  map.get(c)+1);
            }
        }

        return map;
    }

    /**
     * 将两个字符串的字符和数量放入Map中.然后比较Map中每个字符数量是否相等
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNums(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        Map&amp;lt;Character, Integer&amp;gt; map1 = convertMapNums(str1);
        Map&amp;lt;Character, Integer&amp;gt; map2 = convertMapNums(str2);

        if (map1.size() != map2.size()){
            return false;
        }

        boolean isSame = true;
        Set&amp;lt;Character&amp;gt; set1 = map1.keySet();
        for (Character ch: set1) {
            if (map1.get(ch) != map2.get(ch)){
                isSame = false;
                break;
            }
        }

        return isSame;
    }


    /**
     * 如果是Ascii编码,那么不同字符的数量最大为256个,所以可以声明一个长度256的数组,将字符的数量放到这个数组中,然后在一一比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNumsAscii(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        int[] chArr1 = new int[256];
        for (int i = 0; i &amp;lt; str1.length(); i++){
            char ch = str1.charAt(i);
            chArr1[ch] = chArr1[ch]+1;
        }

        int[] chArr2 = new int[256];
        for (int i = 0; i &amp;lt;str2.length(); i++){
            char ch = str2.charAt(i);
            chArr2[ch] = chArr2[ch]+1;
        }

        boolean isSame = true;
        for (int i = 0; i &amp;lt; 256; i++){
            if (chArr1[i] != chArr2[i]){
                isSame = false;
                break;
            }
        }

        return isSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str1=&quot;1234567333&quot;;
        String str2=&quot;7654321333&quot;;

        long startTime = System.nanoTime();
        boolean isSame = isStringEqualByArraysSort(str1, str2);
        long endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByArraysSort: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNums(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNums: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNumsAscii(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNumsAscii: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;效率比较&lt;/h3&gt;

&lt;p&gt;假定这两个字符串的长度为10，那么这三种方法所花费的时间如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isStringEqualByArraysSort: true time:167000
isStringEqualByCharNums: true time:518000
isStringEqualByCharNumsAscii: true time:29000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果能够确定字符串中的字符数量，不是太大的话，优先采用利用数组统计字符数量的方法才是效率最高的。&lt;br /&gt;
不过在工作中直接使用数组排序的解决方式是优先考虑的选择&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>反转一个字符串</title>
        <link>http://disheng54.github.io/2016/07/31/string-ReverseString.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-ReverseString.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;将一个字符串反转&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个常见的问题，在实际的开发中也经常用到，解决的方法有很多种。我使用下面四种方法进行，并且最后比较其中的效率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用系统自带的StringBuilder.reverse()  进行反转。&lt;/li&gt;
  &lt;li&gt;使用将字符串转换为字符数据，然后进行二分反转。&lt;/li&gt;
  &lt;li&gt;使用字符的异或进行转换。&lt;/li&gt;
  &lt;li&gt;使用Stack数据结构进行反转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
     * 利用系统自带的StringBuilder.reverse() 进行反转
     * @param str
     * @return
     */
    public static String reverseByStringBuilder(String str){
        if (str == null){
            return &quot;&quot;;
        }
        return new StringBuilder(str).reverse().toString();
    }

    /**
     * 使用字符串进行二分反转
     * @return
     */
    public static String reverseByCharArray(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length;
        for (int i = (len-1) / 2; i &amp;gt;= 0; i--){
            char c = chArr[i];
            chArr[i] = chArr[len - i -1];
            chArr[len - i -1] = c;
        }

        return new String(chArr);
    }

    /**
     * 使用异或进行翻转
     * 将二进制 a = 1101, b = 1000 进行反转.
     * 1  a = 1101 ^ 1000 此时 a = 1010, b = 1000
     * 2  b = 1000 ^ 1010 此时 a = 1010, b = 1101
     * 3  a = 1101 ^ 1010 此时 a = 1000, b = 1101
     * @return
     */
    public static String reverseByXor(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length ;
        for (int i = 0, j = len -1; i &amp;lt; len/2; i++, j--){
            chArr[i] = (char)(chArr[i]^chArr[j]);
            chArr[j] = (char)(chArr[j]^chArr[i]);
            chArr[i] = (char)(chArr[j]^chArr[i]);
        }

        return new String(chArr);
    }

    /**
     * 使用栈进行翻转
     * @param str
     * @return
     */
    public static String reverseByStack(String str){
        if (str == null){
            return &quot;&quot;;
        }

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int len = str.length();
        for (int i = 0; i &amp;lt; len; i++){
            stack.push(str.charAt(i));
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; len; i++){
            sb.append(stack.pop());
        }
        return sb.toString();
    }



    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str=&quot;&quot;;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i&amp;lt;= 10000; i++){
            sb.append(i+&quot;&quot;);
        }
        str = sb.toString();


        long startTime = System.nanoTime();
        String str1 = reverseByStringBuilder(str);
        long endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    StringBuilder.reverse(): &quot;+str1);


        startTime = System.nanoTime();
        str1 = reverseByCharArray(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByCharArray: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByXor(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByXor: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByStack(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByStack: &quot;+str1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;效率比较 单位是纳秒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:14000  
  reverseByCharArray time:7000 
  reverseByXor time:4000 
  reverseBystack time:315000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为100的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:29000  
  reverseByCharArray time:11000 
  reverseByXor time:9000 
  reverseBystack time:589000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为1000的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:295000 
  reverseByCharArray time:72000 
  reverseByXor time:76000
  reverseBystack time:3949000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10000的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:3321000
  reverseByCharArray time:966000 
  reverseByXor time:1421000
  reverseBystack time:18414000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果比较&lt;/p&gt;

    &lt;p&gt;在字符串较短的情况下通过异或反转所用的时间是最短的，二分数组仅次之。&lt;br /&gt;
 在字符串较长的情况下使用二分数组的是花费时间最短的。&lt;br /&gt;
 使用栈进行反转花费的时间时间最长是二分数组反转的两个数量级。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>判断一个字符串里面的字符都是不相同的</title>
        <link>http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;判断一个字符串里面的字符都是不相同的。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个问题有很多种解决方案，并且可以根据字符串字符集的不同，可以做不同的优化。有下面几种解决问题的思路&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历字符串中的字符与字符串中的其他的字符比较。&lt;/li&gt;
  &lt;li&gt;可以将字符串进行排序，然后比较相邻的字符是否相等。&lt;/li&gt;
  &lt;li&gt;可以利用String方法的lastIndexOf() 方法进行比较。这个方法原理同上。&lt;/li&gt;
  &lt;li&gt;可以借助第三方的数据结构进行，比如Set，List， Map等等。&lt;/li&gt;
  &lt;li&gt;如果是ASCII字符集，那么通过构建一个长度为256默认为false的布尔数组，存在的字符设置为true，将该索引位置第二次设置为true时，就标志着有相同的字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 实现一个算法,判断一个字符串中的所有字符是否全都不同.
 */
public class AnalyzingStringsNoSame {
    private static final String LOG_TAG = &quot;AnalyzingStringsNoSame&quot;;

    /**
     * 将字符串里面的字符取出放入到set中, 如果add 返回false,即认为有相同的字符
     * @param str
     * @return
     */
    public static boolean isSameBySet(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;
        Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; str.length(); i++){
            if(!set.add(str.charAt(i))){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }


    /**
     * 利用String 的 lastIndexOf(int) 来查找
     * @param str
     * @return
     */
    public static boolean isSameByIndex(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            if(str.lastIndexOf(str.charAt(i)) != i){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 将字符串里面的字符和其他的字符串进行比较
     * @param str
     * @return
     */
    public static boolean isSameByTraverse(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            int ca = str.charAt(i);
            for (int j = i+1; j &amp;lt; str.length(); j++){
                if (ca == str.charAt(j)){
                    noSame = false;
                    break;
                }
            }
        }
        return !noSame;
    }


    /**
     * 将字符串排序,然后比较相邻的字符是否相等.
     * @param str
     * @return
     */
    public static boolean isSameBySort(String str){
        if (str == null){
            return false;
        }

        char[] caArr = str.toCharArray();
        Arrays.sort(caArr);

        boolean noSame = true;
        for (int i = 0; i &amp;lt; caArr.length-1;){
            if (caArr[i] == caArr[++i]){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 如果字符串的为ASCII编码,如果字符串的长度大于256,就肯定存在相同的字符.
     * @param str
     * @return
     */
    public static boolean isAsciiSame(String str){
        if (str == null){
            return false;
        }

        if (str.length() &amp;gt; 256){
            return true;
        }

        boolean[] caArr = new boolean[256];

        boolean noSame = true;
        for (int i = 0; i &amp;lt; str.length(); i++){
            int ch = str.charAt(i);
            if (caArr[ch]){
                noSame = false;
                break;
            }
            caArr[ch] = true;
        }
        return !noSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str = &quot;15234d&quot;;
        System.out.println(&quot;字符串:&quot;+str);
        System.out.println(&quot;isSameBySet: &quot;+AnalyzingStringsNoSame.isSameBySet(str));
        System.out.println(&quot;isSameByIndex: &quot;+AnalyzingStringsNoSame.isSameByIndex(str));
        System.out.println(&quot;isSameByTraverse: &quot;+AnalyzingStringsNoSame.isSameByTraverse(str));
        System.out.println(&quot;isSameBySort: &quot;+AnalyzingStringsNoSame.isSameBySort(str));
        System.out.println(&quot;isAsciiSame: &quot;+AnalyzingStringsNoSame.isAsciiSame(str));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>1-Two Sum</title>
        <link>http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;原链接:&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;Two Sum&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;br /&gt;
You may assume that each input would have exactly one solution.&lt;br /&gt;
Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个整型数组，如果该数组中有两个数值的和等于一个特定值，就返回这两个数值在数组中的索引。&lt;br /&gt;
假定有唯一的解决方案。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;假定有一个Map，遍历寻找&lt;code class=&quot;highlighter-rouge&quot;&gt;target-nums[n] &lt;/code&gt;为key对应的value，如果找不到就将nums[n]和索引n作为存放于Map中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;示例代码-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 7/31/16.
 * Given an array of integers, return indices of the two numbers such that they add up to a specific target.

 You may assume that each input would have exactly one solution.

 Example:
 Given nums = [2, 7, 11, 15], target = 9,

 Because nums[0] + nums[1] = 2 + 7 = 9,
 return [0, 1].
 */
public class TwoSum_1 {
    /**
     * 通过hashMap实现
     * @param nums
     * @param target
     * @return
     */
    public static int[] twoSumByHashMap(int[] nums, int target){
        int[] result = new int[2];
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; nums.length; i++){
            if(map.get(target - nums[i]) != null){
                result[0] = map.get(target - nums[i]);
                result[1] = i;
                break;
            }

            map.put(nums[i], i);
        }
        return result;
    }

    public static void main(String[] args){
        int[] nums = {2,7,11,15};
        int target = 9;
        
        long startTime = System.nanoTime();
        int[] result = twoSumByHashMap(nums, target);
        long endTime = System.nanoTime();
        System.out.println(String.format(&quot;time :&quot; + (endTime - startTime)+&quot; [%d, %d]&quot;, result[0], result[1]));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;示例代码-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;


using namespace std;

vector&amp;lt;int&amp;gt; twoSumByArraySort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target)
{
    map&amp;lt;int, int&amp;gt; ht;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        ht.insert(map&amp;lt;int,int&amp;gt;::value_type(nums[i], i));
    }
    vector&amp;lt;int&amp;gt; res(2, -1);
    sort(nums.begin(), nums.end());
    int begin = 0;
    int end = nums.size() -1;

    while(begin &amp;lt; end){
        if(nums[begin] + nums[end] == target){
            res[0] = min(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            res[1] = max(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            break;
        }else if (nums[begin] + nums[end] &amp;lt; target){
            begin ++;
        }else {
            end --;
        }
    }
    return res;
}

int main() {
    vector&amp;lt;int&amp;gt; nums = {2,7,11,15};
    int target = 9;

    clock_t start, finish;

    start = clock();
    vector&amp;lt;int&amp;gt; result = twoSumByMap(nums, target);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot; twoSumByMap:&quot; &amp;lt;&amp;lt;&quot;[&quot;&amp;lt;&amp;lt;result[0]&amp;lt;&amp;lt;&quot;,&quot;&amp;lt;&amp;lt;result[1]&amp;lt;&amp;lt;&quot;]&quot;&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;示例代码-JavaScript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var twoSumByMap = function(nums, target) {
    var map = {};
    for(var i in nums){
      if(map[target-nums[i]] !== undefined){
        return [parseInt(map[target-nums[i]]),parseInt(i)];
      }else{
      map[nums[i]] = i;
      }
    }
};

var nums = [0,4,3,0];
var target = 0;
var beginTime = new Date().getTime();
var result = twoSumByMap(nums, target);
var endTime = new Date().getTime();
console.log(&quot;Time:&quot;+(endTime - beginTime)+&quot; result:&quot;+result);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Mac下安装Tomcat</title>
        <link>http://disheng54.github.io/2016/06/05/javaWeb-mac-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/06/05/javaWeb-mac-install-tomcat.html</guid>
        <pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;tomcat&quot;&gt;一、下载tomcat&lt;/h3&gt;

&lt;p&gt;打开 tomcat官网 &lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;http://tomcat.apache.org/&lt;/a&gt; 选择合适的版本下载&lt;br /&gt;
mac下下载zip和targz都行.这次我选择的是最新的9.0版本下载的。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;二、安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解压刚才下载的文件，命名为tomcat9&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将tomcat9 移动到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library&lt;/code&gt;目录下&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo mv tomcat9 /Library&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;为tomcat9 添加权限 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod 755 /Library/tomcat9/bin/*.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;三、开启和关闭tomcat&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;启动tomcat &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/tomcat9/bin/startup.sh&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080&lt;/a&gt; 打开tomcat 首页&lt;/li&gt;
  &lt;li&gt;关闭 tomcat &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/tomcat9/bin/shutdown.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;四、配置环境变量&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;打开.bash_profile &lt;code class=&quot;highlighter-rouge&quot;&gt;vi ~/.bash_profile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;输入路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;export PATH=$PATH:/Library/tomcat9/bin&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;输入 $PATH 查看刚才输入的路径&lt;/li&gt;
  &lt;li&gt;输入&lt;code class=&quot;highlighter-rouge&quot;&gt; source ~/.bash_profile&lt;/code&gt; 使配置生效&lt;/li&gt;
  &lt;li&gt;测试 配置是否成功&lt;br /&gt;
 在终端输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;startup.sh&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown.sh&lt;/code&gt; 是否启动和关闭tomcat服务器&lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>Git-分支常用命令</title>
        <link>http://disheng54.github.io/2015/05/08/git-git2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/05/08/git-git2.html</guid>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;   Git常用命令－分支 &lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;基本分支管理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    查看分支: git branch
    创建分支: git branch &amp;lt;分支名字&amp;gt;
    切换到另外一个分支: git checkout
    删除一个本地分支: git branch -d &amp;lt;分支名字&amp;gt;
    强制删除一个本地分支: git branch -D &amp;lt;分支名字&amp;gt;
    查看所有的分支: git branch -a 
    查看所有的远程分支: git branch -r
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基本的远程操作&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    查看远程主机，默认为origin: git remote
    查看远程主机版本信息：git remote -v 
    查看制定主机名的远程主机详细信息: git remote show &amp;lt;主机名&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;fetch&quot;&gt;fetch操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    git fetch &amp;lt;远程主机名&amp;gt;:获取远程主机上所有的提交
    git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt; :获取远程主机上一个分支的提交
    git checkout -b &amp;lt;新分支名字&amp;gt; &amp;lt;远程主机名字&amp;gt;/&amp;lt;远程分支名字&amp;gt;:
                   从远程分支更新到本地并在此基础上生成一个新的分支。
    git merge &amp;lt;远程主机名&amp;gt;/&amp;lt;分支名字&amp;gt; 在当前的本地分支上合并远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pull&quot;&gt;pull操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     git pull &amp;lt;远程主机名&amp;gt;&amp;lt;远程分支名字&amp;gt;:&amp;lt;本地分支&amp;gt; ：取回远程主机一个分支的更新，然后与本地的分支合并
 如果是与本地的当前分支合并可忽略:&amp;lt;本地分支&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;push&quot;&gt;push操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名字&amp;gt;:&amp;lt;远程分支名字&amp;gt; :将本地分支的内容提交到远程分支上 。
      如果要提交到的远程分支和本地分支有跟踪关系就可省略 :&amp;lt;远程分支名字&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>MAC下eclipse的常用快捷键</title>
        <link>http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</guid>
        <pubDate>Wed, 08 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;maceclipse-br&quot;&gt;Mac下Eclipse快捷键大全 &lt;br /&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;查找帮助&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     Shift + Command + L: 打开快捷键列表
     Command + F: 打开查找
     Command + K: 在当前页面内搜索选中的关键字。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;页面操作类&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Command + W: 关闭当前编辑页面
    Command + Shift＋W: 关闭当前所有的编辑页面
    Command + Option + 右箭头: 后一个编辑页面
    Command + Option + 左箭头: 前一个编辑页面
    
    Command + t: 快速显示当前类的结构图
    Option + 回车: 显示当前选中资源的属性。
    Command + Option + c: 显示函数结构。
    Command + E: 显示当前可选择页面的列表，仅在右上角显示，可以切换页面。
    Command + Shift + E: 显示当前编辑页面的列表窗口，进行管理。
    
    Command + Shift + P: 匹配定位，比如while循环的两个大括号之间的匹配。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bug&quot;&gt;运行调试修改bug&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Command + 1: 快速修复
    Shift + Command + F11: 运行
    Command + F11: 调试
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;编辑相关&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Command + Option + 上箭头: 复制当前行到上一行。
   Command + Option + 下箭头: 复制当前行到下一行。  
   Option + 上箭头: 向上移动当前行。
   Option + 下箭头: 向下移动当前行。      
   Command + D: 删除当前行
   
   Option + Command + R: 重命名。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>android开发中的资源</title>
        <link>http://disheng54.github.io/2015/01/27/android-resource.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/27/android-resource.html</guid>
        <pubDate>Tue, 27 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;Android 开发资源&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;开发网站&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;优秀博客&lt;/h3&gt;

&lt;h3 id=&quot;ndk&quot;&gt;NDK&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/shulianghan/article/details/18964835&quot;&gt;NDK从入门到精通 介绍的非常详细&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/column/details/blogjnindk.html&quot;&gt;JNI/NDK开发指南 专栏&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cppblog.com/xkjy3000/category/20738.html&quot;&gt;NDK开发教程 不推荐入门看&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>反射-一个简单的实例应用</title>
        <link>http://disheng54.github.io/2015/01/05/java-reflect.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-reflect.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;反射就是通过一个类的名字或者实例，才操作它的属性和方法的机制。该机制在android开发中非常有用。因为android开发中很多API里的一些方法没有公开，就需要用反射机制才能使用它。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;class&quot;&gt;什么是Class&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我定义一个类的时候需要使用Class关机字。比如 Class A{};我们定义了一个名字为A的类对象，那么我们就可以理解为Class 就是类对象A的类型。这个想法有点抽象。
Class类有两个重要的方法。
getName(); 获取这个对象的名字。
forName(); 这个是静态方法。通过一个类的名字，获取到这个类的类型说明，我也不知道该怎么描述，只要不要理解成一个类对象的实例就行。
newInstance(); 通过这个成员方法可以获得一个类的心的实例。
    
下面我我们看一个列子。给一个类的名字，来打印这个类的所有字段和方法。       
 
	/**
	 * TODO 给定一个类名，打印它的属性，方法等等。
	 * yumo
	 * @param className
	 * void
	 * 2015-1-4
	 */
	public void printClass(String className)
	{
		if(className == null || className.length() &amp;lt;=0) return ;
		
		try {
			//返回与带有给定字符串名的类或接口相关联的 Class 对象。
			Class cls = Class.forName(className);
			//一个字符串的权限。
			String modifiers = Modifier.toString(cls.getModifiers());
			System.out.print(modifiers);
			// 打印类的名字
			System.out.print(cls.getName());
			// 获取它的父类。
			Class superCls = cls.getSuperclass();
			if(superCls != null) System.out.print(&quot; extends &quot; + superCls.getName());
			System.out.println(&quot;{&quot;);
			
			//打印field 成员变量
			Field[] fields = cls.getFields();
			for(Field field:fields)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(field.getModifiers());
				System.out.print(modifiers + &quot; &quot;);
				//打印类型
				System.out.print(field.getType() + &quot; &quot;);
				//打印方法的名字
				System.out.print(field.getName());
				
				System.out.println();
			}
			
			//打印methods 
			Method[] methods = cls.getMethods();
			for(Method method : methods)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(method.getModifiers() );
				
				System.out.print(modifiers + &quot; &quot;);
				//打印返回类型
				System.out.print(method.getReturnType().getName() + &quot; &quot;);
				//打印方法的名字
				System.out.print(method.getName()+&quot;(&quot;);
				//打印参数
				Class[] parameters = method.getParameterTypes();
				for(int i = 0; i &amp;lt; parameters.length; i++)
				{
					if(i &amp;gt; 0) System.out.print(&quot;,&quot;);
					Class para = parameters[i];
					System.out.print(para.getName());
				}
				
				System.out.println(&quot;)&quot;);
			}
			
			System.out.println(&quot;}&quot;);
			
			
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}
	
当我们用这个语句打印Date类的方法，printClass(&quot;java.util.Date&quot;);
打印的结果如下，它完整的输出一个类的结构。

	publicjava.util.Date extends java.lang.Object{
	public boolean equals(java.lang.Object)
	public java.lang.String toString()
	public int hashCode()
	public java.lang.Object clone()
	public int compareTo(java.util.Date)
	public volatile int compareTo(java.lang.Object)
	public boolean after(java.util.Date)
	public boolean before(java.util.Date)
	public static long parse(java.lang.String)
	public void setTime(long)
	public long getTime()
	public int getYear()
	public int getMonth()
	public int getDate()
	public int getHours()
	public int getMinutes()
	public int getSeconds()
	public static long UTC(int,int,int,int,int,int)
	public void setDate(int)
	public void setMonth(int)
	public void setHours(int)
	public void setMinutes(int)
	public void setSeconds(int)
	public void setYear(int)
	public int getDay()
	public java.lang.String toLocaleString()
	public java.lang.String toGMTString()
	public int getTimezoneOffset()
	public final void wait()
	public final native void wait(long)
	public final void wait(long,int)
	public final native java.lang.Class getClass()
	public final native void notify()
	public final native void notifyAll()
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;通过反射操作一个类的字段。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 我们定义一个Book类。有两个属性，书名和价格。定义如下。
       /**
	 * yumo
	 * 定义一个用于测试的Book类
	 */
	class Book
	{
		public String name = &quot;&quot;;
		
		public double price = 0.0;
		
		public Book(String name, double price)
		{
			this.name = name;
			this.price = price;
		}
		
		public double getPrice(){
			System.out.println(&quot;getPrice 进入运行了&quot;);
			return price;
		}
		
		public void setPrice(Double price)
		{
			System.out.println(&quot;setPrice 进入运行了&quot;);
			this.price = price;
		}
	}
	
	这里我们先看一个Class的一个方法。
	Field getDeclaredField（String; //给定一个字段名称，获取到该字段的实例。
	Field类是表示一个Class中的一个字段。它主要有三个方法。
	getName(); 获取字段的名称。
	get(Object): 获取制定对象上该字段的值。
	set(Object obj, Object value); 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。
	
	下面就用一个列子来展现它的用法。
	我们首先定义一个Book类的实例，然后通过实例获取到它的类对象clsBook.
	然后通过clsBook的getField(&quot;name&quot;)方法获取到name字段的Field的说明。
	然后调用Field对象的get和set方法对该字段惊醒操作。
	
	Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {
		//获取book对象的，name字段
		Field name = clsBook.getDeclaredField(&quot;name&quot;);
		//获取并打印name的值
		System.out.println(&quot;通过反射获取的书名为：&quot;+name.get(book));
		//修改name的值
		System.out.println(&quot;通过反射获取的将书名修改为：android 开发入门详解&quot;);
		name.set(book, &quot;android 开发入门详解&quot;);
		//输出修改后的name的值
		System.out.println(&quot;通过反射修改后书名为：&quot;+book.name);
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
打印结果如下：

	通过反射获取的书名为：Android高级编程
	通过反射获取的将书名修改为：android 开发入门详解
	通过反射修改后书名为：android 开发入门详解
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通过反射操作一个类的方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们可以通过反射机制在运行当中动态的获取一个实例方法，来操纵这个方法。需要用到相关类的方法如下
Class类中的方法
Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)   返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。
Method 顾名思义表示的一个类型方法类型。它有两个常用的方法。
getName(); 获取这个方法的名称。
Object	invoke(Object obj, Object... args)  对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。
下面我们通过一个列子，领略一下反射魅力。

       Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {			
		//通过反射调用方法
		Method getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;现在书的价格为:&quot;+book.getPrice());
		
		Double price = 100.0;
		Class[] argsCls = new Class[1];
		argsCls[0] = price.getClass();
		
		Method setPrice = clsBook.getMethod(&quot;setPrice&quot;, argsCls);
		setPrice.invoke(book, price);
		System.out.println(&quot;通过反射通过反射将书的价格修改:&quot;+price);
		
		getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;通过反射修改后，书的价格为:&quot;+book.getPrice());
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}

打印结果如下：

	现在书的价格为:74.0
	setPrice 进入运行了
	通过反射通过反射将书的价格修改:100.0
	getPrice 进入运行了
	getPrice 进入运行了
	通过反射修改后，书的价格为:100.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>java 随机数－常用操作集合。</title>
        <link>http://disheng54.github.io/2015/01/05/java-random.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-random.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;随机数用的场合非常多，但是使用起来并不复杂，非常的简单。下面就是他的一些列方法的使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Random random = new Random(100);
	
	//随机生成10个int数字  next()
	System.out.println(&quot;随机生成5个int数字  next()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt());
	}
	
	//生成5个 0到100之间的数字。
	System.out.println(&quot;生成5个 0到100之间的数字。 nextInt(100)&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt(100));
	}
	
	//随机生成5个boolean值
	System.out.println(&quot;随机生成5个boolean值 netBoolean&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextBoolean());
	}
	
	//随机生成5个long值
	System.out.println(&quot;随机生成5个long值 random nextLong()&quot;);
	for(int n =0; n &amp;lt; 10; n++)
	{
		System.out.println(random.nextLong());
	}
	
	//随机生成5个fload值
	System.out.println(&quot;随机生成5个fload值 netFloat&quot;);
	for(int n =0; n &amp;lt;5; n++)
	{
		System.out.println(random.nextFloat()*100);
	}
	
	//随机生成5个double值
	System.out.println(&quot;随机生成5个double值 netDouble&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextDouble()*100);
	}
	
	//随机生成10个Gaussian值
	System.out.println(&quot;随机生成5个太随机数  nextGaussian()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextGaussian()*100);
	}
		
	
	//
	System.out.println(&quot;建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])&quot;);
	
	byte[] bytes= new byte[10];
	random.nextBytes(bytes);
	for(byte bt : bytes)
	{
		System.out.println(bt);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上面的代码。我们可以等到如下的结果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	生成5个 0到100之间的数字。 nextInt(100)
	66
	36
	88
	23
	13
	随机生成5个boolean值 netBoolean
	true
	false
	false
	false
	false
	随机生成5个long值 random nextLong()
	1994076515850003689
	-3505880182545671094
	5294845296780165755
	7666949800837858506
	-9143039415690246354
	1622479998420556049
	5700377594808985065
	234374027031053629
	-7316603517567067640
	3586133391558490009
	随机生成5个fload值 netFloat
	86.28953
	15.13797
	91.9473
	12.135201
	23.321033
	随机生成5个double值 netDouble
	41.3242845037923
	28.672630466619474
	62.46190087763299
	73.14622835577995
	48.603697468545924
	随机生成5个张太随机数  nextGaussian()
	-218.73465232186376
	-139.0458132709607
	-170.60989533724836
	-31.26162845667001
	80.45245617401423
	建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])
	-48
	-50
	-114
	12
	-58
	123
	-118
	-39
	104
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>线程基础 -线程的创建与执行</title>
        <link>http://disheng54.github.io/2015/01/03/java-thread1.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/03/java-thread1.html</guid>
        <pubDate>Sat, 03 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    先在的操作系统基本上都是基于多线程的了，在实际的开发中，多线程是无处不在的。一个java程序运行起来，就会默认打开一个主线程。那什么是线程呢。
    线程依附于一个进程，是操作系统可以调度的最小单位。一个进程中的线程之间共用进程的内存和公共数据。
    使用多线程可以实现并发编程，提高程序的性能。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;如何创建并执行。一个线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    创建一个线程可以通过两种方法，但是最后执行都是调用Thread类的start()方法来启动一个线程。 start()会自动调用run() 执行线程的操作。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过扩展一个Thread对象，来创建一个线程。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* yumo
* 通过继承Thread  创建一个子线程类。
*/    class Thread1 extends Thread{
   //线程启动后自动调用run方法运行
   public void run(){
       System.out.println(&quot;thread1&quot;);
   }    }
	
我们可以调用Thread的start()启动一个线程。
	
Thread1 thread = new Thread1();
thread.start();
	 
最后的运行结果为：
	 
thread1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过继承Runnable接口创建一个线程。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * yumo
  * 通过继承Runnable接口实现Runnable对象，重写其中的run()方法
  */
 class Runnable1 implements Runnable {
	
     @Override
     public void run() {
         // TODO Auto-generated method stub
         System.out.println(&quot;runnable1&quot;);
     }
 }
	
   建立并执行该线程。
          
   Thread thread1 = new Thread(new Runnable1());
   thread1.start();
          
   输出结果为：	
          
   runnable1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>线程基础-手动停止线程</title>
        <link>http://disheng54.github.io/2015/01/02/java-thread2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-thread2.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  线程启动后，run()方法运行结束后，就标志着线程结束并正常退出了。可是在一些情况下，比如软件关闭时，需要停止一些尚在运行的进程。手动停止线程有三种方式  
  1、 Thread自带的stop()方法
  2、 建立标志位来停止线程。
  3、 Thread的Interrupts  方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;stop&quot;&gt;利用Stop()方法停止线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  很不幸该方法已经被弃用了。但是该方法还是 的的确确可以让线程立刻停止的。可是问题就是处在立刻停止上面了。就是Stop()让该线程义无反顾的停止了运行，没有丝毫的犹豫，这就带了很多的问题，让线程里的其他成员和开启线程的类非常的不舒服，比如我希望在任何时候，在线程结束以前都打印一条日志，如果用Stop()方法，就不可能打印那条日志了。如果我们打开一个File，一个Socket，我们希望在线程结束的时候，能够调用一下close方法。这也做不到了。所以还是尽可能的少用Stop()方法吧。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;通过标志位来停止一个线程。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在我以往的开发工作中，我一向是利用利用标志位来手动的停止一个线程的。它的原理就是在run() 方法里面进行一个条件判断，满足条件就接着运行该线程，否则话就进行一些收尾工作，来停止该线程的运行。下面我建立一个不停的打印自己名字的线程，然后 通过一个标志位来结束这个线程。
     
     class Runnable2 implements Runnable{
	
		//初始设置标志位为false
		private boolean mStop = false;
		
		
		/**
		 *  设置停止标志位为true。在run()方法里检测到这个值以后，就会停止线程的运行了。
		 * yumo
		 * void
		 * 2015-1-3
		 */
		public void Stop(){
			mStop = true;
		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				if(mStop) 
				{
					System.out.println(&quot;检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕&quot;);
					break;
				}
				
				System.out.println( Thread.currentThread().getName());
				
				try {
					//让该线程，睡眠50毫秒
					Thread.sleep(50);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			System.out.println(&quot;线程终于结束了&quot;);
		}
		
	}
		
	在上面我们建立了Runnable2 类继承了Runnable接口。现在我们建立一个线程运行起来。
	
	Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	经过打印结果我们发现这是一个死循环，如果不手动停止该线程，它将会一直运行下去。
	
	下面就是利用标志位停止线程发生威力的时候了。
        Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	try {
		Thread.sleep(2000);
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
	runnable.Stop();
	
	最后的输出结果如下：
		............
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕
		线程终于结束了
	
	最后我们看到线程成功的结束了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;interrupt-&quot;&gt;利用interrupt() 来中断线程。&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  单单利用标志位结束一个线程，在某些情况下是非常完美的解决方案，而是线程进行了长时间的睡眠，调用了wait，joint时，就麻烦了，非常有可能进行长时间的阻塞，然后就不能检查标志位来停止一个线程了。关于这点，javaAPI提供一个方法 interrupt(),当线程调用该方法时，如果改线程内部调用了wait,sleep,joint 等等，处于阻塞状态时，就会抛出一个InterruptedException 异常，然后我们就有会在捕获这个异常后进行处理，并判断是否要退出线程，等等。ingerrupt 本身并不能中断一个线程，它能中断的阻塞，修改中断标志位等等。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
  </channel>
</rss>