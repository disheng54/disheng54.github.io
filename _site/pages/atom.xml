<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>禹墨的博客</title>
    <link>http://disheng54.github.io</link>
    <description>禹墨的博客</description>
    
      <item>
        <title>2-Add Two Numbers</title>
        <link>http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</guid>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;题目原地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给出两个标识非负整数的链表，整数在链表中反向存储且链表中的每个节点只存储一个数字。&lt;br /&gt;
将两个整数链表相加，将结果用链表返回&lt;br /&gt;
输入: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
输出: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个简单的问题，只是稍微注意下两个链表长度不一致就可以了。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wks on 8/5/16.
 * You are given two linked lists representing two non-negative numbers.
 * The digits are stored in reverse order and each of their nodes contain a single digit.
 * Add the two numbers and return it as a linked list.
 * &amp;lt;p&amp;gt;
 * Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
 * Output: 7 -&amp;gt; 0 -&amp;gt; 8
 */
public class AddTwoNumbers_2 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int lso = 0;
        int sum = 0;
        ListNode ls = null;
        ListNode nextLn = null;
        while (l1 != null || l2 != null || lso != 0) {
            sum = lso;
            if (l1 != null) sum += l1.val;
            if (l2 != null) sum += l2.val;

            lso = sum / 10;
            ListNode temp = new ListNode(sum % 10);
            if (ls == null) nextLn = ls = temp;
            else{
                nextLn.next = temp;
                nextLn = nextLn.next;
            }

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return ls;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(1027633061);
        ListNode l2 = initListNode(1696698036);
//
//        ListNode l1 = initListNode(342);
//        ListNode l2 = initListNode(465);

//        ListNode l1 = initListNode(5);
//        ListNode l2 = initListNode(5);
        System.out.println(&quot;listNode1 &quot; + ListNodeToString(l1));

        System.out.println(&quot;listNode2 &quot; + ListNodeToString(l2));

        ListNode ls = addTwoNumbers(l1, l2);
        System.out.println(&quot;listNodes &quot; + ListNodeToString(ls));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by yumo on 8/5/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;

struct ListNode
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) { }
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int lso = 0;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while (true){
            int sum = lso;
            if(l1 != NULL){
                sum += l1-&amp;gt;val;
                l1 = l1-&amp;gt;next;
            }
            if(l2 != NULL){
                sum += l2-&amp;gt;val;
                l2 = l2-&amp;gt;next;
            }
            lso = sum /10;
            ListNode* node = new ListNode(sum %10);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }

            if(l1 == NULL &amp;amp;&amp;amp; l2 == NULL &amp;amp;&amp;amp; lso == 0){
                break;
            }
        }

        return ln;
    }

    ListNode* initListNode(int num){
        int mod = 0;
        int temp = num;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while(num  &amp;gt; 0){
            mod = num % 10;
            num = num / 10;
            ListNode* node = new ListNode(mod);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }
        }
        return ln;
    }

    string listNodeToString(ListNode *ln){
        ListNode* next = ln;
        string sb;
        while(next != NULL){
            int val = next-&amp;gt;val;
            next = next-&amp;gt;next;
            sb += to_string(val)+&quot; &quot;;
        }
        return sb;
    }
};

int main()
{
//     int num1 = 342;
//     int num2 = 465;

//    int num1 = 5;
//    int num2 = 5;

      int num1 = 1027633061;
      int num2 = 1696698036;
     Solution solution;

     ListNode* l1 = solution.initListNode(num1);
     ListNode* l2 = solution.initListNode(num2);

     cout&amp;lt;&amp;lt;&quot;l1 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l1)&amp;lt;&amp;lt;endl;
     cout&amp;lt;&amp;lt;&quot;l2 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l2)&amp;lt;&amp;lt;endl;


    clock_t start, finish;

    start = clock();
    ListNode* ln = solution.addTwoNumbers(l1, l2);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot; &amp;lt;&amp;lt; ((double) (finish - start) / CLOCKS_PER_SEC) * 1000000 &amp;lt;&amp;lt;&quot;result: &quot;&amp;lt;&amp;lt;solution.listNodeToString(ln) &amp;lt;&amp;lt; endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-JavaScript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ListNode(val) {
     this.val = val;
     this.next = null;
}

function initListNode(num){
   var mod = 0;
   var ln = null;
   var nextLn = null;
   while(num &amp;gt; 0){
      mod = num % 10;
      num = parseInt(num / 10);
      if(ln == null){
        ln = new ListNode(mod);
        nextLn = ln;
      }else{
        nextLn.next = new ListNode(mod);
        nextLn = nextLn.next;
      }
   }

   return ln;
}

function listNodeToString(ln){
  var str =&quot;&quot;;
  var next = ln;
  while(next != null){
    str += next.val+&quot; &quot;;
    next = next.next;
  }
  return str;
}

var addTwoNumbers = function(l1, l2) {
    var los = 0;
    var ln = null;
    var nextLn = null;
    while(true){
      var sum = los;
      if(l1 != null){
        sum += l1.val;
        l1 = l1.next;
      }

      if(l2 != null){
        sum += l2.val;
        l2 = l2.next;
      }
      if(ln == null){
        nextLn = ln = new ListNode(sum % 10);
      }else{
        nextLn.next = new ListNode(sum % 10);
        nextLn = nextLn.next;
      }

      los = parseInt(sum / 10);
      if(l1 == null &amp;amp;&amp;amp; l2 == null &amp;amp;&amp;amp; los == 0){
         break;
      }
    }

    return ln;
};

// var num1 = 342;
// var num2 = 465;

var num1 = 5;
var num2 = 5;

// var num1 = 342;
// var num2 = 465;

var l1 = initListNode(num1);
var l2 = initListNode(num2);
console.log(&quot;l1:&quot;+listNodeToString(l1));
console.log(&quot;l2:&quot;+listNodeToString(l2));
var ln = addTwoNumbers(l1, l2);
console.log(&quot;result:&quot;+listNodeToString(ln));

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Ubuntu 安装 Tomcat</title>
        <link>http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</guid>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;jdk&quot;&gt;安装JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从官网下载JDK，下载路径 http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.tar.gz&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;jdk-8u101-linux-x64.tar.gz&lt;/code&gt; 移动到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt; 中， 解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/jvm &lt;/code&gt;目录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir jvm
sudo tar -zxvf jdk-8u101-linux-x64.tar.gz -C /usr/lib/jvm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jre&quot;&gt;配置JRE路径&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开环境变量文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vi ~/.bashrc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在文件的末尾添加下面内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_101
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jre-1&quot;&gt;测试JRE&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;java -version&lt;/code&gt;  查看当前的Java路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java version &quot;1.8.0_101&quot;
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;安装tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载tomcat 下载地址：http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M9/bin/apache-tomcat-9.0.0.M9.zip&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将文件移动到 /usr/local 目录下，解压命名为 tomcat9&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cp apache-tomcat-9.0.0.M9.zip /usr/local
  uzip apache-tomcat-9.0.0.M9.zip
  mv apache-tomcat-9.0.0.M9 tomcat9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;启动tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;开启tomcat9 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chomd 755 /usr/local/tomcat9/bin/*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;启动tomcat&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/tomcat9/bin
./startup.sh

Using CATALINA_BASE:   /usr/local/tomcat9
Using CATALINA_HOME:   /usr/local/tomcat9
Using CATALINA_TMPDIR: /usr/local/tomcat9/temp
Using JRE_HOME:        /usr/lib/jvm/jdk1.8.0_101/jre
Using CLASSPATH:       /usr/local/tomcat9/bin/bootstrap.jar:/usr/local/tomcat9/bin/tomcat-juli.jar
Tomcat started.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;测试访问&lt;/h3&gt;

&lt;p&gt;在浏览器中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt; 访问&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>比较两个字符串排序后是否相等</title>
        <link>http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;比较两个字符串排序后是否相等&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;首先比较字符串的长度，长度不相等的字符串，即使排序后也是不相等。&lt;br /&gt;
如果两个字符串长度相符，那么有下面两种方法进行比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让两个字符串分别排序后进行比较&lt;/li&gt;
  &lt;li&gt;比较两个字符串中的每个字符的数量是否相等
    &lt;ol&gt;
      &lt;li&gt;将字符和字符的数量当做Map的key和value，然后分别比较。&lt;/li&gt;
      &lt;li&gt;如果字符串是Ascii编码，那么可以将字符的数量直接放到数组进行优化。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例(Java)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 比较两个字符排序后是否相等
 */
public class StringIsSameAfterSort {


    private static String sort(String str){
        char[] chArr = str.toCharArray();
        Arrays.sort(chArr);
        return new String(chArr);
    }

    /**
     * 通过Arrays.sort进行比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByArraysSort(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        return sort(str1).equals(sort(str2));
    }

    private static Map convertMapNums(String str){
        Map&amp;lt;Character, Integer&amp;gt; map= new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;  str.length(); i++){
            char c = str.charAt(i);
            if (map.get(c) == null){
                map.put(c,  1);
            }else{
                map.put(c,  map.get(c)+1);
            }
        }

        return map;
    }

    /**
     * 将两个字符串的字符和数量放入Map中.然后比较Map中每个字符数量是否相等
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNums(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        Map&amp;lt;Character, Integer&amp;gt; map1 = convertMapNums(str1);
        Map&amp;lt;Character, Integer&amp;gt; map2 = convertMapNums(str2);

        if (map1.size() != map2.size()){
            return false;
        }

        boolean isSame = true;
        Set&amp;lt;Character&amp;gt; set1 = map1.keySet();
        for (Character ch: set1) {
            if (map1.get(ch) != map2.get(ch)){
                isSame = false;
                break;
            }
        }

        return isSame;
    }


    /**
     * 如果是Ascii编码,那么不同字符的数量最大为256个,所以可以声明一个长度256的数组,将字符的数量放到这个数组中,然后在一一比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNumsAscii(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        int[] chArr1 = new int[256];
        for (int i = 0; i &amp;lt; str1.length(); i++){
            char ch = str1.charAt(i);
            chArr1[ch] = chArr1[ch]+1;
        }

        int[] chArr2 = new int[256];
        for (int i = 0; i &amp;lt;str2.length(); i++){
            char ch = str2.charAt(i);
            chArr2[ch] = chArr2[ch]+1;
        }

        boolean isSame = true;
        for (int i = 0; i &amp;lt; 256; i++){
            if (chArr1[i] != chArr2[i]){
                isSame = false;
                break;
            }
        }

        return isSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str1=&quot;1234567333&quot;;
        String str2=&quot;7654321333&quot;;

        long startTime = System.nanoTime();
        boolean isSame = isStringEqualByArraysSort(str1, str2);
        long endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByArraysSort: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNums(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNums: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNumsAscii(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNumsAscii: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;效率比较&lt;/h3&gt;

&lt;p&gt;假定这两个字符串的长度为10，那么这三种方法所花费的时间如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isStringEqualByArraysSort: true time:167000
isStringEqualByCharNums: true time:518000
isStringEqualByCharNumsAscii: true time:29000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果能够确定字符串中的字符数量，不是太大的话，优先采用利用数组统计字符数量的方法才是效率最高的。&lt;br /&gt;
不过在工作中直接使用数组排序的解决方式是优先考虑的选择&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>反转一个字符串</title>
        <link>http://disheng54.github.io/2016/07/31/string-ReverseString.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-ReverseString.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;将一个字符串反转&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个常见的问题，在实际的开发中也经常用到，解决的方法有很多种。我使用下面四种方法进行，并且最后比较其中的效率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用系统自带的StringBuilder.reverse()  进行反转。&lt;/li&gt;
  &lt;li&gt;使用将字符串转换为字符数据，然后进行二分反转。&lt;/li&gt;
  &lt;li&gt;使用字符的异或进行转换。&lt;/li&gt;
  &lt;li&gt;使用Stack数据结构进行反转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
     * 利用系统自带的StringBuilder.reverse() 进行反转
     * @param str
     * @return
     */
    public static String reverseByStringBuilder(String str){
        if (str == null){
            return &quot;&quot;;
        }
        return new StringBuilder(str).reverse().toString();
    }

    /**
     * 使用字符串进行二分反转
     * @return
     */
    public static String reverseByCharArray(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length;
        for (int i = (len-1) / 2; i &amp;gt;= 0; i--){
            char c = chArr[i];
            chArr[i] = chArr[len - i -1];
            chArr[len - i -1] = c;
        }

        return new String(chArr);
    }

    /**
     * 使用异或进行翻转
     * 将二进制 a = 1101, b = 1000 进行反转.
     * 1  a = 1101 ^ 1000 此时 a = 1010, b = 1000
     * 2  b = 1000 ^ 1010 此时 a = 1010, b = 1101
     * 3  a = 1101 ^ 1010 此时 a = 1000, b = 1101
     * @return
     */
    public static String reverseByXor(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length ;
        for (int i = 0, j = len -1; i &amp;lt; len/2; i++, j--){
            chArr[i] = (char)(chArr[i]^chArr[j]);
            chArr[j] = (char)(chArr[j]^chArr[i]);
            chArr[i] = (char)(chArr[j]^chArr[i]);
        }

        return new String(chArr);
    }

    /**
     * 使用栈进行翻转
     * @param str
     * @return
     */
    public static String reverseByStack(String str){
        if (str == null){
            return &quot;&quot;;
        }

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int len = str.length();
        for (int i = 0; i &amp;lt; len; i++){
            stack.push(str.charAt(i));
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; len; i++){
            sb.append(stack.pop());
        }
        return sb.toString();
    }



    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str=&quot;&quot;;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i&amp;lt;= 10000; i++){
            sb.append(i+&quot;&quot;);
        }
        str = sb.toString();


        long startTime = System.nanoTime();
        String str1 = reverseByStringBuilder(str);
        long endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    StringBuilder.reverse(): &quot;+str1);


        startTime = System.nanoTime();
        str1 = reverseByCharArray(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByCharArray: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByXor(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByXor: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByStack(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByStack: &quot;+str1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;效率比较 单位是纳秒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:14000  
  reverseByCharArray time:7000 
  reverseByXor time:4000 
  reverseBystack time:315000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为100的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:29000  
  reverseByCharArray time:11000 
  reverseByXor time:9000 
  reverseBystack time:589000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为1000的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:295000 
  reverseByCharArray time:72000 
  reverseByXor time:76000
  reverseBystack time:3949000
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10000的字符串进行反转&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  StringBuilder.reverse() time:3321000
  reverseByCharArray time:966000 
  reverseByXor time:1421000
  reverseBystack time:18414000 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果比较&lt;/p&gt;

    &lt;p&gt;在字符串较短的情况下通过异或反转所用的时间是最短的，二分数组仅次之。&lt;br /&gt;
 在字符串较长的情况下使用二分数组的是花费时间最短的。&lt;br /&gt;
 使用栈进行反转花费的时间时间最长是二分数组反转的两个数量级。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>判断一个字符串里面的字符都是不相同的</title>
        <link>http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;判断一个字符串里面的字符都是不相同的。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个问题有很多种解决方案，并且可以根据字符串字符集的不同，可以做不同的优化。有下面几种解决问题的思路&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历字符串中的字符与字符串中的其他的字符比较。&lt;/li&gt;
  &lt;li&gt;可以将字符串进行排序，然后比较相邻的字符是否相等。&lt;/li&gt;
  &lt;li&gt;可以利用String方法的lastIndexOf() 方法进行比较。这个方法原理同上。&lt;/li&gt;
  &lt;li&gt;可以借助第三方的数据结构进行，比如Set，List， Map等等。&lt;/li&gt;
  &lt;li&gt;如果是ASCII字符集，那么通过构建一个长度为256默认为false的布尔数组，存在的字符设置为true，将该索引位置第二次设置为true时，就标志着有相同的字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 实现一个算法,判断一个字符串中的所有字符是否全都不同.
 */
public class AnalyzingStringsNoSame {
    private static final String LOG_TAG = &quot;AnalyzingStringsNoSame&quot;;

    /**
     * 将字符串里面的字符取出放入到set中, 如果add 返回false,即认为有相同的字符
     * @param str
     * @return
     */
    public static boolean isSameBySet(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;
        Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; str.length(); i++){
            if(!set.add(str.charAt(i))){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }


    /**
     * 利用String 的 lastIndexOf(int) 来查找
     * @param str
     * @return
     */
    public static boolean isSameByIndex(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            if(str.lastIndexOf(str.charAt(i)) != i){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 将字符串里面的字符和其他的字符串进行比较
     * @param str
     * @return
     */
    public static boolean isSameByTraverse(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            int ca = str.charAt(i);
            for (int j = i+1; j &amp;lt; str.length(); j++){
                if (ca == str.charAt(j)){
                    noSame = false;
                    break;
                }
            }
        }
        return !noSame;
    }


    /**
     * 将字符串排序,然后比较相邻的字符是否相等.
     * @param str
     * @return
     */
    public static boolean isSameBySort(String str){
        if (str == null){
            return false;
        }

        char[] caArr = str.toCharArray();
        Arrays.sort(caArr);

        boolean noSame = true;
        for (int i = 0; i &amp;lt; caArr.length-1;){
            if (caArr[i] == caArr[++i]){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 如果字符串的为ASCII编码,如果字符串的长度大于256,就肯定存在相同的字符.
     * @param str
     * @return
     */
    public static boolean isAsciiSame(String str){
        if (str == null){
            return false;
        }

        if (str.length() &amp;gt; 256){
            return true;
        }

        boolean[] caArr = new boolean[256];

        boolean noSame = true;
        for (int i = 0; i &amp;lt; str.length(); i++){
            int ch = str.charAt(i);
            if (caArr[ch]){
                noSame = false;
                break;
            }
            caArr[ch] = true;
        }
        return !noSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str = &quot;15234d&quot;;
        System.out.println(&quot;字符串:&quot;+str);
        System.out.println(&quot;isSameBySet: &quot;+AnalyzingStringsNoSame.isSameBySet(str));
        System.out.println(&quot;isSameByIndex: &quot;+AnalyzingStringsNoSame.isSameByIndex(str));
        System.out.println(&quot;isSameByTraverse: &quot;+AnalyzingStringsNoSame.isSameByTraverse(str));
        System.out.println(&quot;isSameBySort: &quot;+AnalyzingStringsNoSame.isSameBySort(str));
        System.out.println(&quot;isAsciiSame: &quot;+AnalyzingStringsNoSame.isAsciiSame(str));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>1-Two Sum</title>
        <link>http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;原链接:&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;Two Sum&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;br /&gt;
You may assume that each input would have exactly one solution.&lt;br /&gt;
Example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个整型数组，如果该数组中有两个数值的和等于一个特定值，就返回这两个数值在数组中的索引。&lt;br /&gt;
假定有唯一的解决方案。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;假定有一个Map，遍历寻找&lt;code class=&quot;highlighter-rouge&quot;&gt;target-nums[n] &lt;/code&gt;为key对应的value，如果找不到就将nums[n]和索引n作为存放于Map中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;示例代码-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 7/31/16.
 * Given an array of integers, return indices of the two numbers such that they add up to a specific target.

 You may assume that each input would have exactly one solution.

 Example:
 Given nums = [2, 7, 11, 15], target = 9,

 Because nums[0] + nums[1] = 2 + 7 = 9,
 return [0, 1].
 */
public class TwoSum_1 {
    /**
     * 通过hashMap实现
     * @param nums
     * @param target
     * @return
     */
    public static int[] twoSumByHashMap(int[] nums, int target){
        int[] result = new int[2];
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; nums.length; i++){
            if(map.get(target - nums[i]) != null){
                result[0] = map.get(target - nums[i]);
                result[1] = i;
                break;
            }

            map.put(nums[i], i);
        }
        return result;
    }

    public static void main(String[] args){
        int[] nums = {2,7,11,15};
        int target = 9;
        
        long startTime = System.nanoTime();
        int[] result = twoSumByHashMap(nums, target);
        long endTime = System.nanoTime();
        System.out.println(String.format(&quot;time :&quot; + (endTime - startTime)+&quot; [%d, %d]&quot;, result[0], result[1]));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;示例代码-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;


using namespace std;

vector&amp;lt;int&amp;gt; twoSumByArraySort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target)
{
    map&amp;lt;int, int&amp;gt; ht;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        ht.insert(map&amp;lt;int,int&amp;gt;::value_type(nums[i], i));
    }
    vector&amp;lt;int&amp;gt; res(2, -1);
    sort(nums.begin(), nums.end());
    int begin = 0;
    int end = nums.size() -1;

    while(begin &amp;lt; end){
        if(nums[begin] + nums[end] == target){
            res[0] = min(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            res[1] = max(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            break;
        }else if (nums[begin] + nums[end] &amp;lt; target){
            begin ++;
        }else {
            end --;
        }
    }
    return res;
}

int main() {
    vector&amp;lt;int&amp;gt; nums = {2,7,11,15};
    int target = 9;

    clock_t start, finish;

    start = clock();
    vector&amp;lt;int&amp;gt; result = twoSumByMap(nums, target);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot; twoSumByMap:&quot; &amp;lt;&amp;lt;&quot;[&quot;&amp;lt;&amp;lt;result[0]&amp;lt;&amp;lt;&quot;,&quot;&amp;lt;&amp;lt;result[1]&amp;lt;&amp;lt;&quot;]&quot;&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;示例代码-JavaScript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var twoSumByMap = function(nums, target) {
    var map = {};
    for(var i in nums){
      if(map[target-nums[i]] !== undefined){
        return [parseInt(map[target-nums[i]]),parseInt(i)];
      }else{
      map[nums[i]] = i;
      }
    }
};

var nums = [0,4,3,0];
var target = 0;
var beginTime = new Date().getTime();
var result = twoSumByMap(nums, target);
var endTime = new Date().getTime();
console.log(&quot;Time:&quot;+(endTime - beginTime)+&quot; result:&quot;+result);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Mac下安装Tomcat</title>
        <link>http://disheng54.github.io/2016/06/05/javaWeb-mac-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/06/05/javaWeb-mac-install-tomcat.html</guid>
        <pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;tomcat&quot;&gt;一、下载tomcat&lt;/h3&gt;

&lt;p&gt;打开 tomcat官网 &lt;a href=&quot;http://tomcat.apache.org/&quot;&gt;http://tomcat.apache.org/&lt;/a&gt; 选择合适的版本下载&lt;br /&gt;
mac下下载zip和targz都行.这次我选择的是最新的9.0版本下载的。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;二、安装&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解压刚才下载的文件，命名为tomcat9&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将tomcat9 移动到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library&lt;/code&gt;目录下&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo mv tomcat9 /Library&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;为tomcat9 添加权限 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo chmod 755 /Library/tomcat9/bin/*.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;三、开启和关闭tomcat&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;启动tomcat &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/tomcat9/bin/startup.sh&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://localhost:8080/&quot;&gt;http://localhost:8080&lt;/a&gt; 打开tomcat 首页&lt;/li&gt;
  &lt;li&gt;关闭 tomcat &lt;code class=&quot;highlighter-rouge&quot;&gt;/Library/tomcat9/bin/shutdown.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;section-1&quot;&gt;四、配置环境变量&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;打开.bash_profile &lt;code class=&quot;highlighter-rouge&quot;&gt;vi ~/.bash_profile&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;输入路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;export PATH=$PATH:/Library/tomcat9/bin&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;输入 $PATH 查看刚才输入的路径&lt;/li&gt;
  &lt;li&gt;输入&lt;code class=&quot;highlighter-rouge&quot;&gt; source ~/.bash_profile&lt;/code&gt; 使配置生效&lt;/li&gt;
  &lt;li&gt;测试 配置是否成功&lt;br /&gt;
 在终端输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;startup.sh&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;shutdown.sh&lt;/code&gt; 是否启动和关闭tomcat服务器&lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>Git-分支常用命令</title>
        <link>http://disheng54.github.io/2015/05/08/git-git2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/05/08/git-git2.html</guid>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;   Git常用命令－分支 &lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;基本分支管理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    查看分支: git branch
    创建分支: git branch &amp;lt;分支名字&amp;gt;
    切换到另外一个分支: git checkout
    删除一个本地分支: git branch -d &amp;lt;分支名字&amp;gt;
    强制删除一个本地分支: git branch -D &amp;lt;分支名字&amp;gt;
    查看所有的分支: git branch -a 
    查看所有的远程分支: git branch -r
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基本的远程操作&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    查看远程主机，默认为origin: git remote
    查看远程主机版本信息：git remote -v 
    查看制定主机名的远程主机详细信息: git remote show &amp;lt;主机名&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;fetch&quot;&gt;fetch操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    git fetch &amp;lt;远程主机名&amp;gt;:获取远程主机上所有的提交
    git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt; :获取远程主机上一个分支的提交
    git checkout -b &amp;lt;新分支名字&amp;gt; &amp;lt;远程主机名字&amp;gt;/&amp;lt;远程分支名字&amp;gt;:
                   从远程分支更新到本地并在此基础上生成一个新的分支。
    git merge &amp;lt;远程主机名&amp;gt;/&amp;lt;分支名字&amp;gt; 在当前的本地分支上合并远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pull&quot;&gt;pull操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     git pull &amp;lt;远程主机名&amp;gt;&amp;lt;远程分支名字&amp;gt;:&amp;lt;本地分支&amp;gt; ：取回远程主机一个分支的更新，然后与本地的分支合并
 如果是与本地的当前分支合并可忽略:&amp;lt;本地分支&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;push&quot;&gt;push操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名字&amp;gt;:&amp;lt;远程分支名字&amp;gt; :将本地分支的内容提交到远程分支上 。
      如果要提交到的远程分支和本地分支有跟踪关系就可省略 :&amp;lt;远程分支名字&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>MAC下eclipse的常用快捷键</title>
        <link>http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</guid>
        <pubDate>Wed, 08 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;maceclipse-br&quot;&gt;Mac下Eclipse快捷键大全 &lt;br /&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;查找帮助&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     Shift + Command + L: 打开快捷键列表
     Command + F: 打开查找
     Command + K: 在当前页面内搜索选中的关键字。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;页面操作类&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Command + W: 关闭当前编辑页面
    Command + Shift＋W: 关闭当前所有的编辑页面
    Command + Option + 右箭头: 后一个编辑页面
    Command + Option + 左箭头: 前一个编辑页面
    
    Command + t: 快速显示当前类的结构图
    Option + 回车: 显示当前选中资源的属性。
    Command + Option + c: 显示函数结构。
    Command + E: 显示当前可选择页面的列表，仅在右上角显示，可以切换页面。
    Command + Shift + E: 显示当前编辑页面的列表窗口，进行管理。
    
    Command + Shift + P: 匹配定位，比如while循环的两个大括号之间的匹配。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bug&quot;&gt;运行调试修改bug&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Command + 1: 快速修复
    Shift + Command + F11: 运行
    Command + F11: 调试
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;编辑相关&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Command + Option + 上箭头: 复制当前行到上一行。
   Command + Option + 下箭头: 复制当前行到下一行。  
   Option + 上箭头: 向上移动当前行。
   Option + 下箭头: 向下移动当前行。      
   Command + D: 删除当前行
   
   Option + Command + R: 重命名。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>android开发中的资源</title>
        <link>http://disheng54.github.io/2015/01/27/android-resource.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/27/android-resource.html</guid>
        <pubDate>Tue, 27 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;Android 开发资源&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;开发网站&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;优秀博客&lt;/h3&gt;

&lt;h3 id=&quot;ndk&quot;&gt;NDK&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/shulianghan/article/details/18964835&quot;&gt;NDK从入门到精通 介绍的非常详细&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/column/details/blogjnindk.html&quot;&gt;JNI/NDK开发指南 专栏&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cppblog.com/xkjy3000/category/20738.html&quot;&gt;NDK开发教程 不推荐入门看&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>反射-一个简单的实例应用</title>
        <link>http://disheng54.github.io/2015/01/05/java-reflect.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-reflect.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;反射就是通过一个类的名字或者实例，才操作它的属性和方法的机制。该机制在android开发中非常有用。因为android开发中很多API里的一些方法没有公开，就需要用反射机制才能使用它。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;class&quot;&gt;什么是Class&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我定义一个类的时候需要使用Class关机字。比如 Class A{};我们定义了一个名字为A的类对象，那么我们就可以理解为Class 就是类对象A的类型。这个想法有点抽象。
Class类有两个重要的方法。
getName(); 获取这个对象的名字。
forName(); 这个是静态方法。通过一个类的名字，获取到这个类的类型说明，我也不知道该怎么描述，只要不要理解成一个类对象的实例就行。
newInstance(); 通过这个成员方法可以获得一个类的心的实例。
    
下面我我们看一个列子。给一个类的名字，来打印这个类的所有字段和方法。       
 
	/**
	 * TODO 给定一个类名，打印它的属性，方法等等。
	 * yumo
	 * @param className
	 * void
	 * 2015-1-4
	 */
	public void printClass(String className)
	{
		if(className == null || className.length() &amp;lt;=0) return ;
		
		try {
			//返回与带有给定字符串名的类或接口相关联的 Class 对象。
			Class cls = Class.forName(className);
			//一个字符串的权限。
			String modifiers = Modifier.toString(cls.getModifiers());
			System.out.print(modifiers);
			// 打印类的名字
			System.out.print(cls.getName());
			// 获取它的父类。
			Class superCls = cls.getSuperclass();
			if(superCls != null) System.out.print(&quot; extends &quot; + superCls.getName());
			System.out.println(&quot;{&quot;);
			
			//打印field 成员变量
			Field[] fields = cls.getFields();
			for(Field field:fields)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(field.getModifiers());
				System.out.print(modifiers + &quot; &quot;);
				//打印类型
				System.out.print(field.getType() + &quot; &quot;);
				//打印方法的名字
				System.out.print(field.getName());
				
				System.out.println();
			}
			
			//打印methods 
			Method[] methods = cls.getMethods();
			for(Method method : methods)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(method.getModifiers() );
				
				System.out.print(modifiers + &quot; &quot;);
				//打印返回类型
				System.out.print(method.getReturnType().getName() + &quot; &quot;);
				//打印方法的名字
				System.out.print(method.getName()+&quot;(&quot;);
				//打印参数
				Class[] parameters = method.getParameterTypes();
				for(int i = 0; i &amp;lt; parameters.length; i++)
				{
					if(i &amp;gt; 0) System.out.print(&quot;,&quot;);
					Class para = parameters[i];
					System.out.print(para.getName());
				}
				
				System.out.println(&quot;)&quot;);
			}
			
			System.out.println(&quot;}&quot;);
			
			
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}
	
当我们用这个语句打印Date类的方法，printClass(&quot;java.util.Date&quot;);
打印的结果如下，它完整的输出一个类的结构。

	publicjava.util.Date extends java.lang.Object{
	public boolean equals(java.lang.Object)
	public java.lang.String toString()
	public int hashCode()
	public java.lang.Object clone()
	public int compareTo(java.util.Date)
	public volatile int compareTo(java.lang.Object)
	public boolean after(java.util.Date)
	public boolean before(java.util.Date)
	public static long parse(java.lang.String)
	public void setTime(long)
	public long getTime()
	public int getYear()
	public int getMonth()
	public int getDate()
	public int getHours()
	public int getMinutes()
	public int getSeconds()
	public static long UTC(int,int,int,int,int,int)
	public void setDate(int)
	public void setMonth(int)
	public void setHours(int)
	public void setMinutes(int)
	public void setSeconds(int)
	public void setYear(int)
	public int getDay()
	public java.lang.String toLocaleString()
	public java.lang.String toGMTString()
	public int getTimezoneOffset()
	public final void wait()
	public final native void wait(long)
	public final void wait(long,int)
	public final native java.lang.Class getClass()
	public final native void notify()
	public final native void notifyAll()
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;通过反射操作一个类的字段。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 我们定义一个Book类。有两个属性，书名和价格。定义如下。
       /**
	 * yumo
	 * 定义一个用于测试的Book类
	 */
	class Book
	{
		public String name = &quot;&quot;;
		
		public double price = 0.0;
		
		public Book(String name, double price)
		{
			this.name = name;
			this.price = price;
		}
		
		public double getPrice(){
			System.out.println(&quot;getPrice 进入运行了&quot;);
			return price;
		}
		
		public void setPrice(Double price)
		{
			System.out.println(&quot;setPrice 进入运行了&quot;);
			this.price = price;
		}
	}
	
	这里我们先看一个Class的一个方法。
	Field getDeclaredField（String; //给定一个字段名称，获取到该字段的实例。
	Field类是表示一个Class中的一个字段。它主要有三个方法。
	getName(); 获取字段的名称。
	get(Object): 获取制定对象上该字段的值。
	set(Object obj, Object value); 将指定对象变量上此 Field 对象表示的字段设置为指定的新值。
	
	下面就用一个列子来展现它的用法。
	我们首先定义一个Book类的实例，然后通过实例获取到它的类对象clsBook.
	然后通过clsBook的getField(&quot;name&quot;)方法获取到name字段的Field的说明。
	然后调用Field对象的get和set方法对该字段惊醒操作。
	
	Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {
		//获取book对象的，name字段
		Field name = clsBook.getDeclaredField(&quot;name&quot;);
		//获取并打印name的值
		System.out.println(&quot;通过反射获取的书名为：&quot;+name.get(book));
		//修改name的值
		System.out.println(&quot;通过反射获取的将书名修改为：android 开发入门详解&quot;);
		name.set(book, &quot;android 开发入门详解&quot;);
		//输出修改后的name的值
		System.out.println(&quot;通过反射修改后书名为：&quot;+book.name);
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
打印结果如下：

	通过反射获取的书名为：Android高级编程
	通过反射获取的将书名修改为：android 开发入门详解
	通过反射修改后书名为：android 开发入门详解
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通过反射操作一个类的方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;我们可以通过反射机制在运行当中动态的获取一个实例方法，来操纵这个方法。需要用到相关类的方法如下
Class类中的方法
Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)   返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。
Method 顾名思义表示的一个类型方法类型。它有两个常用的方法。
getName(); 获取这个方法的名称。
Object	invoke(Object obj, Object... args)  对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。
下面我们通过一个列子，领略一下反射魅力。

       Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {			
		//通过反射调用方法
		Method getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;现在书的价格为:&quot;+book.getPrice());
		
		Double price = 100.0;
		Class[] argsCls = new Class[1];
		argsCls[0] = price.getClass();
		
		Method setPrice = clsBook.getMethod(&quot;setPrice&quot;, argsCls);
		setPrice.invoke(book, price);
		System.out.println(&quot;通过反射通过反射将书的价格修改:&quot;+price);
		
		getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;通过反射修改后，书的价格为:&quot;+book.getPrice());
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}

打印结果如下：

	现在书的价格为:74.0
	setPrice 进入运行了
	通过反射通过反射将书的价格修改:100.0
	getPrice 进入运行了
	getPrice 进入运行了
	通过反射修改后，书的价格为:100.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>java 随机数－常用操作集合。</title>
        <link>http://disheng54.github.io/2015/01/05/java-random.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-random.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;随机数用的场合非常多，但是使用起来并不复杂，非常的简单。下面就是他的一些列方法的使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    Random random = new Random(100);
	
	//随机生成10个int数字  next()
	System.out.println(&quot;随机生成5个int数字  next()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt());
	}
	
	//生成5个 0到100之间的数字。
	System.out.println(&quot;生成5个 0到100之间的数字。 nextInt(100)&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt(100));
	}
	
	//随机生成5个boolean值
	System.out.println(&quot;随机生成5个boolean值 netBoolean&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextBoolean());
	}
	
	//随机生成5个long值
	System.out.println(&quot;随机生成5个long值 random nextLong()&quot;);
	for(int n =0; n &amp;lt; 10; n++)
	{
		System.out.println(random.nextLong());
	}
	
	//随机生成5个fload值
	System.out.println(&quot;随机生成5个fload值 netFloat&quot;);
	for(int n =0; n &amp;lt;5; n++)
	{
		System.out.println(random.nextFloat()*100);
	}
	
	//随机生成5个double值
	System.out.println(&quot;随机生成5个double值 netDouble&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextDouble()*100);
	}
	
	//随机生成10个Gaussian值
	System.out.println(&quot;随机生成5个太随机数  nextGaussian()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextGaussian()*100);
	}
		
	
	//
	System.out.println(&quot;建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])&quot;);
	
	byte[] bytes= new byte[10];
	random.nextBytes(bytes);
	for(byte bt : bytes)
	{
		System.out.println(bt);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上面的代码。我们可以等到如下的结果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	生成5个 0到100之间的数字。 nextInt(100)
	66
	36
	88
	23
	13
	随机生成5个boolean值 netBoolean
	true
	false
	false
	false
	false
	随机生成5个long值 random nextLong()
	1994076515850003689
	-3505880182545671094
	5294845296780165755
	7666949800837858506
	-9143039415690246354
	1622479998420556049
	5700377594808985065
	234374027031053629
	-7316603517567067640
	3586133391558490009
	随机生成5个fload值 netFloat
	86.28953
	15.13797
	91.9473
	12.135201
	23.321033
	随机生成5个double值 netDouble
	41.3242845037923
	28.672630466619474
	62.46190087763299
	73.14622835577995
	48.603697468545924
	随机生成5个张太随机数  nextGaussian()
	-218.73465232186376
	-139.0458132709607
	-170.60989533724836
	-31.26162845667001
	80.45245617401423
	建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])
	-48
	-50
	-114
	12
	-58
	123
	-118
	-39
	104
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>线程基础 -线程的创建与执行</title>
        <link>http://disheng54.github.io/2015/01/03/java-thread1.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/03/java-thread1.html</guid>
        <pubDate>Sat, 03 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    先在的操作系统基本上都是基于多线程的了，在实际的开发中，多线程是无处不在的。一个java程序运行起来，就会默认打开一个主线程。那什么是线程呢。
    线程依附于一个进程，是操作系统可以调度的最小单位。一个进程中的线程之间共用进程的内存和公共数据。
    使用多线程可以实现并发编程，提高程序的性能。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;如何创建并执行。一个线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    创建一个线程可以通过两种方法，但是最后执行都是调用Thread类的start()方法来启动一个线程。 start()会自动调用run() 执行线程的操作。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;通过扩展一个Thread对象，来创建一个线程。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* yumo
* 通过继承Thread  创建一个子线程类。
*/    class Thread1 extends Thread{
   //线程启动后自动调用run方法运行
   public void run(){
       System.out.println(&quot;thread1&quot;);
   }    }
	
我们可以调用Thread的start()启动一个线程。
	
Thread1 thread = new Thread1();
thread.start();
	 
最后的运行结果为：
	 
thread1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过继承Runnable接口创建一个线程。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /**
  * yumo
  * 通过继承Runnable接口实现Runnable对象，重写其中的run()方法
  */
 class Runnable1 implements Runnable {
	
     @Override
     public void run() {
         // TODO Auto-generated method stub
         System.out.println(&quot;runnable1&quot;);
     }
 }
	
   建立并执行该线程。
          
   Thread thread1 = new Thread(new Runnable1());
   thread1.start();
          
   输出结果为：	
          
   runnable1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>线程基础-手动停止线程</title>
        <link>http://disheng54.github.io/2015/01/02/java-thread2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-thread2.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  线程启动后，run()方法运行结束后，就标志着线程结束并正常退出了。可是在一些情况下，比如软件关闭时，需要停止一些尚在运行的进程。手动停止线程有三种方式  
  1、 Thread自带的stop()方法
  2、 建立标志位来停止线程。
  3、 Thread的Interrupts  方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;stop&quot;&gt;利用Stop()方法停止线程&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  很不幸该方法已经被弃用了。但是该方法还是 的的确确可以让线程立刻停止的。可是问题就是处在立刻停止上面了。就是Stop()让该线程义无反顾的停止了运行，没有丝毫的犹豫，这就带了很多的问题，让线程里的其他成员和开启线程的类非常的不舒服，比如我希望在任何时候，在线程结束以前都打印一条日志，如果用Stop()方法，就不可能打印那条日志了。如果我们打开一个File，一个Socket，我们希望在线程结束的时候，能够调用一下close方法。这也做不到了。所以还是尽可能的少用Stop()方法吧。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;通过标志位来停止一个线程。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  在我以往的开发工作中，我一向是利用利用标志位来手动的停止一个线程的。它的原理就是在run() 方法里面进行一个条件判断，满足条件就接着运行该线程，否则话就进行一些收尾工作，来停止该线程的运行。下面我建立一个不停的打印自己名字的线程，然后 通过一个标志位来结束这个线程。
     
     class Runnable2 implements Runnable{
	
		//初始设置标志位为false
		private boolean mStop = false;
		
		
		/**
		 *  设置停止标志位为true。在run()方法里检测到这个值以后，就会停止线程的运行了。
		 * yumo
		 * void
		 * 2015-1-3
		 */
		public void Stop(){
			mStop = true;
		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				if(mStop) 
				{
					System.out.println(&quot;检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕&quot;);
					break;
				}
				
				System.out.println( Thread.currentThread().getName());
				
				try {
					//让该线程，睡眠50毫秒
					Thread.sleep(50);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			System.out.println(&quot;线程终于结束了&quot;);
		}
		
	}
		
	在上面我们建立了Runnable2 类继承了Runnable接口。现在我们建立一个线程运行起来。
	
	Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	经过打印结果我们发现这是一个死循环，如果不手动停止该线程，它将会一直运行下去。
	
	下面就是利用标志位停止线程发生威力的时候了。
        Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	try {
		Thread.sleep(2000);
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
	runnable.Stop();
	
	最后的输出结果如下：
		............
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕
		线程终于结束了
	
	最后我们看到线程成功的结束了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;interrupt-&quot;&gt;利用interrupt() 来中断线程。&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  单单利用标志位结束一个线程，在某些情况下是非常完美的解决方案，而是线程进行了长时间的睡眠，调用了wait，joint时，就麻烦了，非常有可能进行长时间的阻塞，然后就不能检查标志位来停止一个线程了。关于这点，javaAPI提供一个方法 interrupt(),当线程调用该方法时，如果改线程内部调用了wait,sleep,joint 等等，处于阻塞状态时，就会抛出一个InterruptedException 异常，然后我们就有会在捕获这个异常后进行处理，并判断是否要退出线程，等等。ingerrupt 本身并不能中断一个线程，它能中断的阻塞，修改中断标志位等等。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>String源码阅读分析</title>
        <link>http://disheng54.github.io/2015/01/02/java-string1.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-string1.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java String类是一个使用频率非常高的类。借助分析String类的源码，有助于更好的了解java中字符串的操作，写出更加有效率的代码。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;string-&quot;&gt;String 定义&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   public final class String implements Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence｛｝
   String首先是一个final类，它将不能被继承生成一个子类。String为什么要设置为final类型主要有2个方面的考虑。
   1、处于安全性的考虑.String类是java中一个非常底层的类，和操作系统进行的频繁的交互。如果可以String类可以被继承，用户就可能会重写String类的相关方法，这就提供破坏操作系统提供了机会，降低了java的宣称的安全性。
   2、效率的问题：String被定义为final类，那么它的所有方法都是final的，jvm编译器会内联所有的方法，此举可以让String类的效率使用50%，单凭这点就让人心动不已了。
   
   String类继承了Serializable ,所以String类是可序列化的。
   String类继承了Comparable, 所以String可以在集合里面，直接用sort()排序。
   String类继承实现了CharSequence ,所以String类本质上是一个字符序列。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;string--1&quot;&gt;String 成员变量&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //定义一个字符数组来存放 String的字符序列。
  private final char[] value;
  // 字符偏移的位置。
  private final int offset;
  //String的字符的个数。可以通过length() 方法返回。
  private final int count;
  //该字符串对应生产的一个哈希值。
  private int hashCode;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;string--2&quot;&gt;String 初始化&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    String的类的初始化方法非常多，非常的丰富，所以初始化String对象还是很方便的。
    
    //声明一个空字符串
     public String() {
          value = EmptyArray.CHAR;
          offset = 0;
         count = 0;
    }
    
    利用byte[] 生成为字符串。
    //下面几个是利用字节数组转换一个新的String对象。将字节数组解码为字符串的字符集可以制定，也可使使用系统默认
    public String(byte[] data) ;//将一个字节数组生成一个新的字符串。使用默认字符集
    public String(byte[] data, int offset, int byteCount) ；将数组从offset位置后读取byteCount个字节转换为数组。使用默认字符集。
    
    将字节数据转换为从offset位置读取byteCount个字节转换为数组，使用用户指定的字符集，如果不支持该字符集，就抛出UnsupportedEncodingException.
    public String(byte[] data, int offset, int byteCount, String charsetName) throws UnsupportedEncodingException 
    将字节数据转换为从offset位置读取byteCount个字节转换为数组，使用用户指定的字符集，如果不支持该字符集，就抛出UnsupportedEncodingException.
    public String(byte[] data, int offset, int byteCount, Charset charset) ;
    利用用户制定的字符集.将byte数组生成一个新的字符串。
    public String(byte[] data, Charset charset) ;
    
    利用char[] 声明一个字符串。
     public String(char[] data)//将一个char数组声明一个新的String对象。内部调用public String(char[] data, int offset, int charCount)实现
      
      /**
    * 用char数组生命一个新的字符串变量。然后然后修改这个char数组将不再影响新生成的字符串。	    *
    * 当 data为null的时候，报空指针异常。
    * @throws IndexOutOfBoundsException
    *             if {@code charCount &amp;lt; 0 || offset &amp;lt; 0 || offset + charCount &amp;gt; data.length}
    */
   public String(char[] data, int offset, int charCount) {
      //检查是否越界
       if ((offset | charCount) &amp;lt; 0 || charCount &amp;gt; data.length - offset) {
           throw failedBoundsCheck(data.length, offset, charCount);
       }
       this.offset = 0;
       //新生成一个string对象 ，所有新生的char数组和旧的数组没有关联。
       this.value = new char[charCount];
       this.count = charCount;
       System.arraycopy(data, offset, value, 0, count);
   }
   
   /*
     * 直接用char数组生产一个字符串对象。其中char[]没有在new 一个新的数组，所以二者是一个char数组。	     * Does not range check, null check, or copy the character array.
     */
    String(int offset, int charCount, char[] chars) {
        this.value = chars;
        this.offset = offset;
        this.count = charCount;
    }
    
     /**
     * 用一个字符串的副本构造一个新的字符串。
     */
    public String(String toCopy) {
        value = (toCopy.value.length == toCopy.count)
                ? toCopy.value
                : Arrays.copyOfRange(toCopy.value, toCopy.offset, toCopy.offset + toCopy.length());
        offset = 0;
        count = value.length;
    }

     /**
     * 用字符缓冲区的字符序列构建一个字符串。是线程安全的。
     * {@code StringBuffer}.
     */
    public String(StringBuffer stringBuffer) {
        offset = 0;
        synchronized (stringBuffer) {
            value = stringBuffer.shareValue();
            count = stringBuffer.length();
        }
    }

    /**
     * 用int数组构建一个字符串，字符串的序列为unicode字符。	     *
     * @throws NullPointerException
     *             if {@code codePoints == null}.
     * @throws IllegalArgumentException
     *             if any of the elements of {@code codePoints} are not valid
     *             Unicode code points.
     * @throws IndexOutOfBoundsException
     *             if {@code offset} or {@code count} are not within the bounds
     *             of {@code codePoints}.
     * @since 1.5
     */
    public String(int[] codePoints, int offset, int count) {
        if (codePoints == null) {
            throw new NullPointerException(&quot;codePoints == null&quot;);
        }
        if ((offset | count) &amp;lt; 0 || count &amp;gt; codePoints.length - offset) {
            throw failedBoundsCheck(codePoints.length, offset, count);
        }
        this.offset = 0;
        //unicode 字符占用两个字节，int型数据为4个字节。所以要乘以二。
        this.value = new char[count * 2];
        int end = offset + count;
        int c = 0;
        for (int i = offset; i &amp;lt; end; i++) {
            c += Character.toChars(codePoints[i], this.value, c);
        }
        this.count = c;
    }

    /**
     * 构建一个新的string对象，包含字符串生成器的字符序列。
     *
     * @throws NullPointerException
     *             if {@code stringBuilder == null}.
     * @since 1.5
     */
    public String(StringBuilder stringBuilder) {
        if (stringBuilder == null) {
            throw new NullPointerException(&quot;stringBuilder == null&quot;);
        }
        this.offset = 0;
        this.count = stringBuilder.length();
        this.value = new char[this.count];
        stringBuilder.getChars(0, this.count, this.value, 0);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Git常用操作</title>
        <link>http://disheng54.github.io/2015/01/01/git-git.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/01/git-git.html</guid>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 以前一直使用GitHub的图像客户的来操作自己版本库的提交和更新。现在感觉效率不高，虽下定决心要在命令行下面操作Git。所以我有必要把平时要使用Git命令整理一份文档出来，从而可以更熟练的使用Git。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;基础配置&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 查看配置:git config --list
 设置全局用户名:git config --global user.name &quot;gitname&quot;
 设置全局邮箱:git config --global user.email &quot;git@com.cn&quot;
 查看全局用户名:git config user.name
 查看全局邮箱:git config user.email
 设置当前仓库用户名:git config --global user.name &quot;gitname&quot;
 设置当前仓库邮箱:git config --global user.email &quot;git@com.cn&quot;
 查看当前仓库用户名:git config user.name
 查看当前仓库邮箱:git config user.email
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;获取帮助&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 查看帮助:git help config
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;初始化一个版本&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git init:在一个目录下面，初始化一个Git版本库。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;克隆一个服务器版本&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git clone https://github.com/disheng54/disheng54.github.io.git
  git clone https://github.com/disheng54/disheng54.github.io.git newdir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-4&quot;&gt;查看本地状态&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git status
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;把改动暂存起来。&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git add  .     
  git add 文件名
  git commit -m &quot;更新说明&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-6&quot;&gt;删除文件&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  删除文件：git rm 文件名称
  删除暂存或已提交的文件：git rm --cached  文件名。
  删除一个目录： git rm -r  --cached  目录名。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更新文件的名字&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; git mv 旧文件名字 新文件名字
 git commit－m &quot;更新文件名字&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-8&quot;&gt;提交文件&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;提交:git  commit -m &quot;提交说明&quot;
重新提交:git  commit  --amend 重新提交
重置文件:git  reset HEAD 文件名
撤销修改:git  checkout  -- 文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-9&quot;&gt;忽略一些文件&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat .gitignore
# Built application files
*.apk 
*.ap_

# Files for the Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-10&quot;&gt;查看提交日志&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;查看日志: git log
显示每次的内容差异: git log -p 。
显示最近的两次更新: git log  -2 
近显示简要的增改行数: git log --stat 。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-11&quot;&gt;在本地初始化一个版本库，然后提交到服务器版本&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git init
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/disheng54/yumoJava.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-12&quot;&gt;远程库&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 显示远程库: git remote -v
 查看远程库信息: git remote show origin
 向远程服务器提交数据: git push origin 分支名字
 删除远程仓库: git remote rm origin
 重命名远程仓库: git remote rename origin origin1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-13&quot;&gt;标签&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 显示标签: git  tag
 显示其中一个标签: git tag -i &quot;tagone&quot; 
 添加一个标签: git  tag  -a v0.1  -m &quot;test tag&quot;
 显示标签: git show v0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Android http开发（－） 下载web页面</title>
        <link>http://disheng54.github.io/2015/01/01/android-http.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/01/android-http.html</guid>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Android中HTTP协议的开发还是比较重要的，熟练的掌握HTTP开发，有助于开发效率，给用户一个更加优秀的APP产品。Android 中使用HTTP协议开发可以使用java自带的API－HttpURLConnection，也可以使用Apache HttpClient。下面就以这两种方式分别实现对一个web页面的下载。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;httpurlconnection-&quot;&gt;(-)HttpURLConnection 实现一个页面的下载。&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * TODO
 * yumo 利用java的HttpConnectionURL 访问一个网站，并获取它的网站数据。
 * @param url 要下载web页面的网址，比如Http://www.baidu.com
 * @return
 * int
 * 2015-1-1
 */
private int getByJavaHttp(String webSite)
{
	int statusCode = -1;
	try {
		//见一个一个URL
		URL url = new URL(webSite);
		//访问web页面
		HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();
		//获取返回的状态吗。
		statusCode = httpConnection.getResponseCode();
		//获取下砸的web页面数据。
		InputStream inputStream = new BufferedInputStream(httpConnection.getInputStream());
		Reader reader = new InputStreamReader(inputStream);
		String strResult = &quot;&quot;;
		int c;
		while( (c = reader.read()) != -1)
		{
			strResult += String.valueOf((char)c);
		}
		Log.d(TAG,&quot;getByJavaHttp: &quot; + strResult);
	} catch (MalformedURLException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return statusCode ;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;apachehttpclient-web&quot;&gt;（二） 通过ApacheHttpClient 实现一个web页面的下载&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * TODO
 * yumo 打印网站的数据 利用Apache httpClient
 * @param url 网站名称 比如http://www.baidu.com
 * @return
 * int 返回请求结果
 * 2015-1-1
 */
private int getByApacheHttp(String url) 
{
	int statusCode = -1;
	//建立一个网络请求
	HttpGet httpRequest = new HttpGet(url);
	HttpClient httpClient = new DefaultHttpClient();
	try {
		//执行请求网络。
		HttpResponse httpResponse = httpClient.execute(httpRequest);
		//获取网络状态吗
		statusCode = httpResponse.getStatusLine().getStatusCode(); 
		if( statusCode == HttpStatus.SC_OK)
		{
			//如果成功获取数据则打印日志。
			String strResult = EntityUtils.toString(httpResponse.getEntity());
			Log.d(TAG, &quot;getByAndroidHttp:&quot;+strResult);
		}else
		{
			Log.d(TAG,&quot;getByAndroidHttp errorCode :&quot;+ statusCode);
		}
	} catch (ClientProtocolException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return statusCode;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>mou 常用快捷键</title>
        <link>http://disheng54.github.io/2014/12/24/mac-moushortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2014/12/24/mac-moushortcut.html</guid>
        <pubDate>Wed, 24 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;显示预览窗口 Toggle live preview: Shift + Cmd + I&lt;/li&gt;
  &lt;li&gt;显示字数 Toggle Words Counter: Shift + Cmd + W&lt;/li&gt;
  &lt;li&gt;将当前窗口设置为透明窗口 Toggle Transparent: Shift + Cmd + T&lt;/li&gt;
  &lt;li&gt;固定当前窗口 Toggle Floating: Shift + Cmd + F&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口相等 Left/Right = 1/1: Cmd + 0&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口的显示比例为 3:1 Left/Right = 3/1: Cmd + +&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口的显示比例为 1:3 Left/Right = 1/3: Cmd + -&lt;/li&gt;
  &lt;li&gt;文字方向 Toggle Writing orientation: Cmd + L&lt;/li&gt;
  &lt;li&gt;全屏显示开关 Toggle fullscreen: Control + Cmd + F&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actions&quot;&gt;Actions&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Copy HTML: Option + Cmd + C&lt;/li&gt;
  &lt;li&gt;重点显示选中文本 Strong: Select text, Cmd + B&lt;/li&gt;
  &lt;li&gt;将选中文本斜体显示 Emphasize:Select text, Cmd + I&lt;/li&gt;
  &lt;li&gt;Inline Code: Select text, Cmd + K&lt;/li&gt;
  &lt;li&gt;加删除线 Strikethrough: Select text, Cmd + U&lt;/li&gt;
  &lt;li&gt;插入超链接 Link: Select text, Control + Shift + L&lt;/li&gt;
  &lt;li&gt;插入图像 Image: Select text, Control + Shift + I&lt;/li&gt;
  &lt;li&gt;选中当前单词 Select Word: Control + Option + W&lt;/li&gt;
  &lt;li&gt;选中当前行 Select Line: Shift + Cmd + L&lt;/li&gt;
  &lt;li&gt;选中所有 Select All: Cmd + A&lt;/li&gt;
  &lt;li&gt;取消选中所有 Deselect All: Cmd + D&lt;/li&gt;
  &lt;li&gt;将选中文本 转化为大写字母 Convert to Uppercase: Select text, Control + U&lt;/li&gt;
  &lt;li&gt;将选中文本 转化为小写字母 Convert to Lowercase: Select text, Control + Shift + U&lt;/li&gt;
  &lt;li&gt;将选中文本所有单词的首字母转为大写Convert to Titlecase: Select text, Control + Option + U&lt;/li&gt;
  &lt;li&gt;将选中文本插入编号 Convert to List: Select lines, Control + L&lt;/li&gt;
  &lt;li&gt;将选中文本转换成引用块 Convert to Blockquote: Select lines, Control + Q&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为1级标题 Convert to H1: Cmd + 1&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为2级标题 Convert to H2: Cmd + 2&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为3级标题 Convert to H3: Cmd + 3&lt;/li&gt;
  &lt;li&gt;将当前行转化为4级标题 Convert to H4: Cmd + 4&lt;/li&gt;
  &lt;li&gt;将当前行转化为5级标题 Convert to H5: Cmd + 5&lt;/li&gt;
  &lt;li&gt;将当前行转化为6级标题 Convert to H6: Cmd + 6&lt;/li&gt;
  &lt;li&gt;Convert Spaces to Tabs: Control + [&lt;/li&gt;
  &lt;li&gt;Convert Tabs to Spaces: Control + ]&lt;/li&gt;
  &lt;li&gt;插入当前日期 Insert Current Date: Control + Shift + 1&lt;/li&gt;
  &lt;li&gt;插入当前时间 Insert Current Time: Control + Shift + 2&lt;/li&gt;
  &lt;li&gt;插入&amp;lt;符号 Insert entity &amp;lt;: Control + Shift + ,&lt;/li&gt;
  &lt;li&gt;插入&amp;gt;符号 Insert entity &amp;gt;: Control + Shift + .&lt;/li&gt;
  &lt;li&gt;插入$符号 Insert entity &amp;amp;: Control + Shift + 7&lt;/li&gt;
  &lt;li&gt;Insert entity Space: Control + Shift + Space&lt;/li&gt;
  &lt;li&gt;Insert Scriptogr.am Header: Control + Shift + G&lt;/li&gt;
  &lt;li&gt;左缩进 Shift Line Left: Select lines, Cmd + [&lt;/li&gt;
  &lt;li&gt;右缩进 Shift Line Right: Select lines, Cmd + ]&lt;/li&gt;
  &lt;li&gt;插入下一行 New Line: Cmd + Return&lt;/li&gt;
  &lt;li&gt;添加注释 Comment: Cmd + /&lt;/li&gt;
  &lt;li&gt;插入换行符 Hard Linebreak: Control + Return&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;edit&quot;&gt;Edit&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;自动完成单词 Auto complete current word: Escape&lt;/li&gt;
  &lt;li&gt;查找 voiceFind: Cmd + F&lt;/li&gt;
  &lt;li&gt;取消查找框 Close find bar: Esc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;post&quot;&gt;Post&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Post on Scriptogr.am: Control + Shift + S&lt;/li&gt;
  &lt;li&gt;提交到 Tunblr Post on Tumblr: Control + Shift + T&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;export&quot;&gt;Export&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;导出为HTML格式文件 Export HTML: Option + Cmd + E&lt;/li&gt;
  &lt;li&gt;导出为PDF格式文件 Export PDF:  Option + Cmd + P&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>mac 常用快捷键</title>
        <link>http://disheng54.github.io/2014/12/10/mac-shortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2014/12/10/mac-shortcut.html</guid>
        <pubDate>Wed, 10 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;mac--br&quot;&gt;mac 常用快捷键 &lt;br /&gt;&lt;/h1&gt;

&lt;h4 id=&quot;section&quot;&gt;文件操作&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Command + A: 全部选中文件
   Option + Command＋A: 取消全部选中的文件。
   Command + C:   拷贝选中的文件
   Command + D:   复制所选项
   Command + V:   粘贴选中的文件
   Command + X:   剪切选中的文件
   Command + Z:   撤销上一步操作
   Shift + Command + Z: 撤销刚才的撤销       
   Command + delete: 移到废纸篓
   shift + Command + delete: 清到废纸篓
   Option + shift + Command + delete: 不提示删除废纸篓。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;应用操作&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Command + tab: 向前切换到上一个窗口
   Shift + Command + tab: 向后切换应用
   Command + W: 关闭当前窗口
   Option + Command + W: 关闭所有的窗口
   Shift + Option + Command +ESC: 强制退出当前的应用程序 按住3秒钟
   
   Command + N: 复制当前的应用，新生成一个窗口
   Command + M: 最小化窗口
   Shift + Command + M:  最小化所有窗口
   
   Command + ]: 向后
   Command + [: 向前
   
   Command + shift +?: 打开帮助
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;文件编辑&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   Control + A: 移动到段落和行的开始。
   Control + E: 移动到段落和行的结束
   Control + B: 向后移动一个字符
   Control + F: 向前移动一个字符	   
   Control + D: 删除光标前的字符
   Control + H: 删除光标后的字符
   Control + K: 删除光标到行或者到断尾的内容
   Control + L: 显示在区域位置中间
   Control + N: 下移一行
   Control + P: 上移一行
   Control + O: 在光标后插入一行
   Control + T: 将光标前后的字好准备。
   Control + V: 进入下页。
   
   Control + 方向键: 聚焦视图内的另外一个值或单元格。
   
   Command + {: 使所选内容左对齐
   Command + }:  使所选内容右对齐
   Command + I: 使所选内容剧中对齐。
   
   Command + 右箭头: 将插入点移到行尾
   Command + 左箭头: 将插入点移到行首
   Command + 上箭头: 将插入移到文稿开头
   Command + 下箭头: 将插入点移到文稿结尾
   
   Shift + 右箭头: 将选中文本范围向右扩充一个字符。
   Shift + 左箭头: 将选中文本范围向左扩充一个字符。
   Shift + 上箭头: 将文件扩充到上一行相同位置。
   Shift +下箭头: 将选中文件扩充至下一行相同位置。
   
   Shift + Command + 右箭头: 选中当前点到行尾之间的内容。
   Shift + Command + 左箭头: 选中当前点到行首之间的内容。
   Shift + Command + 上箭头: 选中当前点到文稿首部的之间的内容。
   Shift + Command + 下箭头: 选中当前点到文稿尾部之间的内容。
   
   Shift + Option + 右箭头: 将选中文本扩充单当前词的尾部，再按一次，扩充至下一词的尾部。
   Shift + Option + 左箭头: 将选中文件扩充至当前词的首部，在按一次，扩充至上一词的首部。
   Shift + Option + 上箭头: 将选中文本扩充至当前段落的首部，再按一次，扩充至上一段路的首部。
   Shift + Option + 下箭头: 将选中文本扩充至当前段落的尾部，再按一次，扩充至下一段落的尾部。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;finder&quot;&gt;Finder&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   shift + Command + A: 打开应用程序
   shift + command + D: 打开桌面文件夹
   shift + Command + C: 打开电脑窗口
   shift + Command + U: 打开实用工具
   shift + Command + G: 打开前往
   shift + Command + F: 打开所有的我的所有文件
   shift + Command + O: 打开文稿
   shift + Command + L: 下载
   shift + Command + H: 个人
   shift + Command + J: iCloud Drive
   shift + Command + R: AirDrop          
   Command + K: 连接服务器
   
   Command + 上箭头: 打开所含的文件夹
   Control + Command + 上箭头: 新窗口中打开上级文件夹
   
   Command + J: 调出显示选项       
   Command + i: 查看简介
   空格键 快速查看
   Option + Command + Y: 以浏览的方式打开
   shift + Command + N: 新建文件夹
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
  </channel>
</rss>