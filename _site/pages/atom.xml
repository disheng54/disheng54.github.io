<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>禹墨的博客</title>
    <link>http://disheng54.github.io</link>
    <description>禹墨的博客</description>
    
      <item>
        <title>26-Remove Duplicates from Sorted Array</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-26-RemoveDuplicatesFromSortedArray.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-26-RemoveDuplicatesFromSortedArray.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&quot;&gt;26. Remove Duplicates from Sorted Array&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;
&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;

&lt;p&gt;For example,&lt;br /&gt;
Given input array nums =&lt;code&gt; [1,1,2]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Your function should return length = &lt;code&gt;2&lt;/code&gt;, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个排好序的数组，移除重复的元素，然后返回新的数组长度。&lt;br /&gt;
要求不能额外一个数组大小的空间来实现，要求使用空间实现，&lt;br /&gt;
比如：输入数组=&lt;code&gt; [1,1,2]&lt;/code&gt;,&lt;br /&gt;
你的方法将返回长度为=&lt;code&gt;2&lt;/code&gt;，两个元素分别是1和2。这个方法并不关心新长度。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;首先这是一个已经排好序的数组，又要求不能额外的分配一个数组空间来实现。&lt;br /&gt;
所以我们可以利用遍历一遍数组来实现。利用前后两个索引值i,j分别向后移动来&lt;br /&gt;
实现去重有序数组的大小。&lt;br /&gt;
时间复杂度为O(n)&lt;br /&gt;
空间复杂度为O(2)&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by yumodev on 9/18/16.
 */
public class RemoveDuplicates_26 {

    public static int removeDuplicates(int[] nums){
        if (nums == null){
            return 0;
        }

        if (nums.length &amp;lt;= 1){
            return 1;
        }

        int i = 0, j = 1;
        while (i &amp;lt;nums.length &amp;amp;&amp;amp; j &amp;lt; nums.length){
            if (nums[i] == nums[j]){
                j++;
            }else{
                nums[++i] = nums[j];
                j++;
            }
        }

        return i+1;
    }

    public static void main(String[] args){
        int[] nums = {2,7,11,15};
        long startTime = System.nanoTime();
        int result = removeDuplicates(nums);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot; removeDuplicates:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>23-Swap Nodes in Pairs</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-24-SwapNodesInPairs.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-24-SwapNodesInPairs.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/swap-nodes-in-pairs/&quot;&gt;24. Swap Nodes in Pairs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;

&lt;p&gt;For example,&lt;br /&gt;
Given &lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4,&lt;/code&gt; you should return the list as &lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个链表，交互相邻的两个节点，并返回链表的头部。&lt;br /&gt;
比如：给定链表&lt;code&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4,&lt;/code&gt; 应该返回&lt;code&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;&lt;br /&gt;
应当使用常量空间时间，不能修改节点的值，但是可以修改节点本身。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这道题目有两个限定条件：&lt;br /&gt;
1、使用常量空间实现；2、不能修改节点的值。&lt;br /&gt;
所以声明一个节点为ln(0),其next指向head, temp节点为临时节点。&lt;br /&gt;
ln.next表示第一个节点，ln.next.next 标识第二个节点。&lt;br /&gt;
现在需要的工作就是讲ln.next, ln.next.next 交互位置。&lt;br /&gt;
通过下面方法来实现ln.next 和 ln.next.next 位置的呼唤。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      temp = ln.next;
      ln.next = ln.next.next;
      temp.next = ln.next.next;
      ln.next.next = temp;     
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;时间复杂度为O(n),&lt;br /&gt;
  空间夫再度为O(2);&lt;br /&gt;
### 代码示例-Java&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by yumodev on 9/13/16.
 */
public class SwapPairs_24 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }

        int n = 1;

        ListNode ln = new ListNode(0);
        ln.next = head;
        head = head.next;
        ListNode temp;
        while (true){
            if (n % 2 == 0){
                temp = ln.next;
                ln.next = ln.next.next;
                temp.next = ln.next.next;
                ln.next.next = temp;
                ln = ln.next.next;
            }

            if (ln.next == null || ln.next.next == null){
                break;
            }

            n++;
        }

        return head;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(4321);
        //ListNode l1 = initListNode(321);
        long startTime = System.nanoTime();
        ListNode l2 = swapPairs(l1);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;removeNthFromEnd:&quot; + ListNodeToString(l2) + &quot; time:&quot; + time);
    }

}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>21-Merge Two Sorted Lists</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-21-MergeTwoSortedLists.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-21-MergeTwoSortedLists.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot;&gt;21. Merge Two Sorted Lists&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;将两个有序链表合并成一个新的链表。新的链表应该有由这两个链表的头部拼接而成。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;按照题意新链表有这两个有序链表的头部拼接而成，所以需要先找到比较两个链表的头部，&lt;br /&gt;
将较小的那个当做新链表的头部，然后同时遍历两个链表进行拼接就行了。&lt;br /&gt;
时间复杂度为:O(m+n)&lt;br /&gt;
空间复杂度为:O(0)&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null ){
            return l2;
        }

        if (l2 == null){
            return l1;
        }

        ListNode ln;
        ListNode head;
        if (l1.val &amp;lt; l2.val){
            head = ln = l1;
            l1 = l1.next;
        }else{
            head = ln = l2;
            l2 = l2.next;
        }

        while (l1 != null || l2 != null){
            if (l1 == null){
                ln.next = l2;
                break;
            }else if (l2 == null){
                ln.next = l1;
                break;
            }

            if (l1.val &amp;lt; l2.val){
                ln.next = l1;
                ln = ln.next;
                l1 = l1.next;
            }else{
                ln.next = l2;
                ln = ln.next;
                l2 = l2.next;
            }
        }

        return head;
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>20-Valid Parentheses</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-20-IsValidParentheses.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-20-IsValidParentheses.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot;&gt;20. Valid Parentheses&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’ and ‘]’, determine if the input string is valid.&lt;br /&gt;
The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给一个仅包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[’ 和 ‘]’的字符串，然后判断这个字符串是否是有效的。&lt;br /&gt;
括号必须按照顺序进行闭合，比如”()” 和 “()[]{}” 都是有效的，但是 “(]” 和 “([)]” 不是有效的.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这是一个典型的栈应用的例子。如果是字符’(‘，’[’, ‘{‘, 将其压入栈，如果是’)’,’]’,’}’&lt;br /&gt;
就从栈中取顶部字符，如果栈为空或者不相匹配，那么就可以认定是无效的。&lt;br /&gt;
如果和栈顶元素匹配，就继续遍历字符串判定。&lt;br /&gt;
时间复杂度：O(n)&lt;br /&gt;
空间复杂度：O(2)&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; public static boolean isValid(String s) {
        if (s == null ||s.length() &amp;lt;= 1){
            return false;
        }

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;= s.length()-1;i++){
            Character ch = s.charAt(i);
            if (ch == &#39;(&#39; || ch == &#39;[&#39; || ch == &#39;{&#39;){
                stack.push(ch);
            }else{
                if (stack.size() == 0){
                    return false;
                }

                Character sch = stack.pop();

                if (ch == &#39;)&#39;){
                    if (sch != &#39;(&#39;){
                        return false;
                    }
                }else if (ch == &#39;]&#39;){
                    if (sch != &#39;[&#39;){
                        return false;
                    }
                }else if (ch == &#39;}&#39;){
                    if (sch != &#39;{&#39;){
                        return false;
                    }
                }
            }
        }
        return stack.size() == 0;
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>19-Remove Nth Node From End of List</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-19-RemoveNthFromEnd.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-19-RemoveNthFromEnd.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&quot;&gt;19. Remove Nth Node From End of List&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;br /&gt;
For example,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.
   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/code&gt;&lt;br /&gt;
Note:&lt;br /&gt;
Given n will always be valid.&lt;br /&gt;
Try to do this in one pass.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个链表，删除倒数第n个节点，然后返回这链表的头部。&lt;br /&gt;
比如：&lt;br /&gt;
 &lt;code&gt;给定链表： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5,  n = 2.
  从尾部移除第2个节点, 然后链表变为： 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：给定的n总是有效的，尝试一次通过。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;建立一前一后两个节点:firstLn, secondLn.&lt;br /&gt;
初始化firstLn的next 指向链表头部，secondLn指向链表头部&lt;br /&gt;
先将firstLn移动n个位置，然后开始移动SecondLn节点。&lt;br /&gt;
当FirstLn移动到链表结尾后，此时需要将SecondLn的下一个节点移除即可。&lt;br /&gt;
时间复杂度为：O(n);&lt;br /&gt;
空间复杂度为：O(1);&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;public ListNode removeNthFromEnd(ListNode head, int n) {
        if (n == 0 || head == null){
            return head;
        }

        ListNode firstLn = head;
        ListNode secondLn = new ListNode(0);
        int pos = 1;

        while (firstNextLn != null){
            if (pos == n){
                secondNextLn.next = head;
            }else if (pos &amp;gt; n){
                secondNextLn = secondNextLn.next;
            }

            firstNextLn = firstNextLn.next;
            pos++;
        }

        if (secondNextLn != null){
            if (secondNextLn.next.equals(head)){
                return head.next;
            }else{
                secondNextLn.next = secondNextLn.next.next;
            }

        }


        return head;
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>14-Longest Common Prefix</title>
        <link>http://disheng54.github.io/2016/09/12/leetcode-14-LongestCommonPrefix.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/12/leetcode-14-LongestCommonPrefix.html</guid>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot;&gt;14. Longest Common Prefix&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;编写一个方法来查找一个字符串数组中最长的公共前缀字符串。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道题目的意思是求取所有字符串的最长前缀公共字符串。采用暴力比较的方法是最简单。&lt;br /&gt;
就是循环获取第一个字符串的前缀子串，将这个子串分别和其他字符串的相同索引的子串进行比较，&lt;br /&gt;
如果任意一个其他字符串的前缀子串和第一字符串的前缀子串不相符，那么除去这个前缀子串的最后一个字符，就是最大的公共前缀子串&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by yumodev on 9/12/16.
 */
public class LongestCommonPrefix_14 {
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0){
            return &quot;&quot;;
        }


        for (int i = 0; i &amp;lt; strs[0].length(); i++){
            for (int j = 1; j &amp;lt; strs.length; j++){
                if (strs[j].length() &amp;lt;= i || strs[j].charAt(i) != strs[0].charAt(i)){
                    return strs[0].substring(0, i);
                }
            }
        }

        return strs[0];
    }

    public static void main(String[] args) {
        String[] str = {&quot;121&quot;, &quot;12&quot;, &quot;21&quot;};
        long startTime = System.nanoTime();
        String result = longestCommonPrefix(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;longestCommonPrefix:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>13-Roman to Integer</title>
        <link>http://disheng54.github.io/2016/09/12/leetcode-13-RomanToInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/12/leetcode-13-RomanToInteger.html</guid>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot;&gt;13. Roman to Integer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;br /&gt;
Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;将给定的一个罗马数字字符串转换为整数&lt;br /&gt;
假定的输入范围是1到3999.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道里面本身很简单，其实难点在于必须要明白罗马数字的标识方法。&lt;br /&gt;
罗马数字一共有七个大写字符，分别是：&lt;code&gt;I、V、X、L、C、D、M&lt;/code&gt;。&lt;br /&gt;
下面是罗马字符和整数的对应关系。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;罗马字符&lt;/th&gt;
      &lt;th&gt;整数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;罗马字符串的计算规则就是&lt;br /&gt;
1、从左向右一次计算。&lt;br /&gt;
2、如果一个罗马字符对应的整数比它后面的字符对应的整数小，那么就讲后面的字符对应的整数减去它对应的整数。&lt;br /&gt;
如果一个罗马字符对应的整数不小于它后面的字符对应的整数，那么就讲后面的字符对应的整数加上它对应的整数。&lt;br /&gt;
下面是一个罗马字符串和整数的对应计算实例&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;罗马字符串&lt;/th&gt;
      &lt;th&gt;整数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;III&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IV&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VI&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IX&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XI&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IL&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LX&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IM&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VM&lt;/td&gt;
      &lt;td&gt;995&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XM&lt;/td&gt;
      &lt;td&gt;990&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LM&lt;/td&gt;
      &lt;td&gt;950&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CM&lt;/td&gt;
      &lt;td&gt;900&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DM&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MI&lt;/td&gt;
      &lt;td&gt;1001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MV&lt;/td&gt;
      &lt;td&gt;1005&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;1010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ML&lt;/td&gt;
      &lt;td&gt;1050&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MC&lt;/td&gt;
      &lt;td&gt;1100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MD&lt;/td&gt;
      &lt;td&gt;1500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MDCCCLXXXIV&lt;/td&gt;
      &lt;td&gt;1884&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码示例&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by yumodev on 9/12/16.
 */
public class RomanToInteger_13 {
    public static int romanToInt(String s) {
        if (s == null || s.length() == 0){
            return 0;
        }

        int result = 0;
        for (int i = 0; i &amp;lt; s.length();i++){
            char ch = s.charAt(i);
            switch (ch){
                case &#39;I&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; s.charAt(i + 1) != &#39;I&#39;){
                        result -= 1;
                    }else{
                        result += 1;
                    }
                    break;
                }
                case &#39;V&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; (s.charAt(i + 1) != &#39;I&#39; &amp;amp;&amp;amp; s.charAt(i + 1) != &#39;V&#39;)){
                        result -= 5;
                    }else{
                        result += 5;
                    }
                    break;
                }
                case &#39;X&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; ( s.charAt(i + 1) == &#39;C&#39; || s.charAt(i + 1) == &#39;L&#39; || s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 10;
                    }else{
                        result += 10;
                    }
                    break;
                }
                case &#39;L&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; ( s.charAt(i + 1) == &#39;C&#39; || s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 50;
                    }else{
                        result += 50;
                    }
                    break;
                }
                case &#39;C&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; (s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 100;
                    }else{
                        result += 100;
                    }
                    break;
                }
                case &#39;D&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; s.charAt(i + 1) == &#39;M&#39;){
                        result -= 500;
                    }else{
                        result += 500;
                    }
                    break;
                }
                case &#39;M&#39;:{
                    result += 1000;
                    break;
                }

            }

        }

        return result;
    }

    public static void main(String[] args) {
        String str = &quot;MDCCCLXXXIV&quot;;
        long startTime = System.nanoTime();
        int result = romanToInt(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;romanToInt:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>9-Palindrome Number</title>
        <link>http://disheng54.github.io/2016/08/26/leetcode-9-PalindromeNumber.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/26/leetcode-9-PalindromeNumber.html</guid>
        <pubDate>Fri, 26 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-number/&quot;&gt;9. Palindrome Number&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;/p&gt;

&lt;p&gt;Some hints:&lt;br /&gt;
Could negative integers be palindromes? (ie, -1)&lt;/p&gt;

&lt;p&gt;If you are thinking of converting the integer to string, note the restriction of using extra space.&lt;/p&gt;

&lt;p&gt;You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?&lt;/p&gt;

&lt;p&gt;There is a more generic way of solving this problem.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;在不需要额外空间的情况下，判定一个整数是否是回文字符串。&lt;br /&gt;
一些提示：&lt;br /&gt;
一个负整数是回文字符串吗?(比如 &lt;code&gt;-1&lt;/code&gt;)&lt;br /&gt;
如果你想把一个整数转换为字符串，需要注意不需要额外的空间的限制。&lt;br /&gt;
也许你会反转整数，如果你已经解决了这道题目”Reverse Integer”, 你就会知道反转字符串也许会发生溢出，然后你该如何处理这种情况呢。&lt;br /&gt;
有一个更加通用的方式来解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这道题目需要考虑一些特殊的情况，比如负数不认为是一个负数&lt;br /&gt;
判断一个整数 x 是不是回文字符串，那么就把这个整数反转后，判断和 x 是不是相等就可以了。&lt;br /&gt;
题目中整数溢出问题，是不需要考虑的，凡是反转后发生溢出的，那么肯定不是回文串。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/25/16.
 */
public class PalindromeNumber_9 {
    public static  boolean isPalindrome(int x) {
        if (x &amp;lt; 0){
            return false;
        }

        int los = 0;
        int temp = x;

        while (temp &amp;gt; 0){
            los = los * 10 + temp % 10;
            temp = temp / 10;
        }

        return los == x;
    }

    public static void main(String[] args) {
        int number = 121;
        long startTime = System.nanoTime();
        boolean result = isPalindrome(number);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>8-String to Integer</title>
        <link>http://disheng54.github.io/2016/08/25/leetcode-8-StringToInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/25/leetcode-8-StringToInteger.html</guid>
        <pubDate>Thu, 25 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;

&lt;p&gt;Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;

&lt;p&gt;Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.&lt;/p&gt;

&lt;p&gt;Requirements for atoi:&lt;br /&gt;
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;

&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;

&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;

&lt;p&gt;If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;实现方法 &lt;code&gt;atoi&lt;/code&gt; 将一个字符串转换为整数&lt;br /&gt;
提示：请考虑到所有输入的情况。如果你想要挑战一下自己，就可以不用开下面的注意事项然后问题自己，都有哪些输入情况。&lt;br /&gt;
注意：这道题目的定义是模糊的(没有给输入的限定条件)，你需要自己考虑所有的输入情况。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;atoi &lt;/code&gt; 方法的要求：&lt;br /&gt;
该方法要求忽略字符串开始的空白字符，一直到第一个非空白字符为止。然后从这个字符开始，先判断初始的正负字符，然后选取尽可能多的数字字符，并将它们转换为一个数值。&lt;br /&gt;
也许该字符串的有效数字后面还有一些额外的非数字字符，那么将忽略这些字符。&lt;br /&gt;
如果第一个非空白字符不是数字字符，或者改字符串是个空串，或者只包含空白字符，则不执行转换。&lt;br /&gt;
如果未执行有效的转换，就返回 &lt;code&gt;0&lt;/code&gt; .如果转换后的数字超出了 &lt;code&gt;int&lt;/code&gt; 类型标识数字的的范围，那么返回&lt;code&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道题目比较简单，正如题目的里面的讲的那样，难点是要考虑到各种的情况。&lt;br /&gt;
1、空字符串、空白字符串、没有有效数字的字符串，返回0&lt;br /&gt;
2、需要去除前面的无效空白字符。&lt;br /&gt;
3、考虑第一个非空字符，如果是 &lt;code&gt;+&lt;/code&gt; 标识正值，如果是&lt;code&gt; -&lt;/code&gt; 标识负值。&lt;br /&gt;
4、忽略有效数字字符后面的所有无效字符，比如：&lt;code&gt;&#39;   -123&amp;amp;456&#39; &lt;/code&gt;转换为 &lt;code&gt;-123&lt;/code&gt;&lt;br /&gt;
5、如果转换后的整数值，超过了返回就返回返回&lt;code&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/22/16.
 */
public class Atoi_8 {
    public static int myAtoi(String str) {
        if (str == null ||str.trim().length() == 0){
            return  0;
        }

        int index = 0;
        while ((index &amp;lt; str.length()) &amp;amp;&amp;amp; (str.charAt(index) == &#39; &#39;)){
            index ++;

        }

        int sign = 1;
        if (str.charAt(index) == &#39;+&#39;){
            sign = 1;
            index ++;
        }else if (str.charAt(index) == &#39;-&#39;){
            sign = -1;
            index ++;
        }

        long result = 0L;
        for (int i = index; i &amp;lt; str.length(); i++){
           if( str.charAt(i) &amp;gt;=  &#39;0&#39; &amp;amp;&amp;amp; str.charAt(i) &amp;lt;= &#39;9&#39;){
                result = result * 10 + (str.charAt(i) - &#39;0&#39;);
               if (sign == 1){
                   if(result &amp;gt; Integer.MAX_VALUE){
                       result = Integer.MAX_VALUE;
                       break;
                   }
               }else{
                   if (result*sign &amp;lt; Integer.MIN_VALUE){
                       result = Integer.MIN_VALUE;
                       break;
                   }
               }
           }else{
               break;
           }
        }

        return (int)result * sign;
    }

    public static void main(String[] args) {
        //String str = &quot;  -214748364734dd&quot;;
        String str = &quot;  -00134&quot;;
        long startTime = System.nanoTime();
        int result = myAtoi(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}

&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>7-Reverse Integer</title>
        <link>http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</guid>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Have you thought about this?&lt;br /&gt;
Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;

&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;

&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;反转一个整数数据&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意：在编码之前有一些问题需要考虑，如果你已经考虑了这些问题，这将是你的加分点。&lt;br /&gt;
如果该整数的最后一位是0，那么僵该输出什么呢？比如 10， 100&lt;br /&gt;
反转后的整数也许会产生溢出，假定输入的是一个32位的整数，如果反转&lt;code&gt;1000000003&lt;/code&gt;将产生溢出，那这种情况该如何处理呢？&lt;br /&gt;
如果发生了溢出，就直接返回为0.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;需要考虑三个方面的问题。&lt;br /&gt;
1. 需要考虑负数的反转。&lt;br /&gt;
2. 如果整数的末尾是0，比如10， 100， 那么反转后为1， 1&lt;br /&gt;
3. 如果反转后产生了溢出，那么就直接返回 0&lt;/p&gt;

&lt;p&gt;解决思路为：&lt;br /&gt;
定义一个long 类型的变量result，来存储反转后的整数&lt;br /&gt;
然后循环反转,注意负数的问题，同时检测到发生了溢出，就返回0&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/17/16.
 * 反正整形字符串
 */
public class ReverseInteger_7 {
    public static int reverse(int x) {
        long result = 0;
        while (x != 0){
            result = result * 10 + x % 10;
            x = x / 10;

            if (result &amp;gt; Integer.MAX_VALUE || result &amp;lt; Integer.MIN_VALUE){
                result = 0;
                break;
            }
        }

        return (int)result;
    }

    public static void main(String[] args) {
        int x  = 1000000003;
        long startTime = System.nanoTime();
        int result = reverse(x);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>6-ZigZag Conversion</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/&quot;&gt;6. ZigZag Conversion&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;The string &lt;code&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then read line by line: &lt;code&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;br /&gt;
Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;string convert(string text, int nRows);&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; should return &lt;code&gt;&quot;PAHNAPLSIIGYIR&quot;.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;将字符串&lt;code&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt;按照给定的行数，转为成锯齿形的字符串。然后将该锯齿形字符串一次读成&lt;code&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写代码将给定的字符串和行数，将字符串进行锯齿转换。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;string convert(string text, int nRows);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; 返回 &lt;code&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;如果nRows = 1， 那么直接返回。&lt;br /&gt;
如果nRows = 2, 转换字符串为：&lt;code&gt;PYAIHRNAPLSIIG&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P	 Y	 A	 I	 H	 R	 N
A	 P	 L	 S	 I	 I	 G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 nRows = 3  转换字符串为：&lt;code&gt;PAHNAPLSIIGYIR&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 nRows = 4 转换字符串为：&lt;code&gt;PINALSIGYAHRPI&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;P 			I			N
A		L	S		I	G
Y	A		H	R
P			I
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过上面可以总结出一个规律，第一行和最后一行两个数据的间距为: &lt;code&gt;2 * nRows -2 &lt;/code&gt;&lt;br /&gt;
中间第 i 行，第1列和它临近字符的间距为: &lt;code&gt;2*nRows -2 - 2 * i&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/16/16.
 */
public class ZigZag_6 {

    public static String convert(String s, int numRows){
        if (numRows &amp;lt;= 1 || s == null || s.length() == 0){
            return s;
        }

        StringBuilder sb = new StringBuilder();
        int size = 2 * numRows -2;
        for (int i = 0; i &amp;lt; numRows; i++){
            for (int j = i; j &amp;lt; s.length();j+= size){
                sb.append(s.charAt(j));
                if (i != 0 &amp;amp;&amp;amp; i != numRows -1){
                    int temp = j + size - 2 * i;
                    if (temp &amp;lt; s.length()){
                        sb.append(s.charAt(temp));
                    }
                }
            }
        }

        return sb.toString();
    }

    public static void main(String[] args) {
       // String str = &quot;PAYPALISHIRING&quot;;
        String str = &quot;A&quot;;
        int nRows = 1;
        long startTime = System.nanoTime();
        String zigZag = convert(str, nRows);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;ZigZag:&quot; + zigZag + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>5-Longest Palindromic Substring</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;给定一个字符串 S，找出其中最长的回文子串。假定 S的最长长度为1000，且存在唯一的最长回文子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个题目可以利用动态规划的方法进行处理。&lt;br /&gt;
假定字符串的长度为len, 声明一个二维数组：dp = new boolean[len][len]&lt;br /&gt;
dp[i][j] 标识字符串S 中S[i~j]的子串是不是回文字符串。&lt;br /&gt;
判断S[i~j]如果是回文串，必须满足两个条件：&lt;br /&gt;
1. S[i] = S[j] &lt;br /&gt;
2. dp[i+1][j-1] = true。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by wks on 8/8/16.
 */
public class LongestPalindrome_5 {
    /**
     * 利用动态规划的方法.
     * @param s
     * @return
     */
    public static String longestPalindrome(String s){
        if (s == null || s.length() == 1) {
            return s;
        }

        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int begin = 0, end = 0, max = 1;

        for (int i = len - 1; i &amp;gt;= 0; i--){
            for (int j = i; j &amp;lt; len; j++){
                if (s.charAt(i) == s.charAt(j)){
                    if (j - i &amp;lt;= 2 ||  (dp[i+1][j-1] &amp;amp;&amp;amp; j-1 &amp;gt; 0)){
                        dp[i][j] = true;
                        if (max &amp;lt; j - i + 1){
                            max = j - i + 1;
                            begin = i;
                            end = j;
                        }
                    }
                }
            }
        }


        return s.substring(begin, end+1);
    }

    public static void main(String[] args) {
        String str = &quot;1aba12&quot;;
        long startTime = System.nanoTime();
        String palindrome = longestPalindrome(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;palindrome:&quot; + palindrome + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>4-Median of Two Sorted Arrays</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br /&gt;
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The median is 2.0&lt;br /&gt;
Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The median is (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;有两个排序且长度分别为m和n的数组nums1 和 nums2。找出这两个排序的中间值。&lt;br /&gt;
要求运行时间为O(log(m+n))&lt;/p&gt;

&lt;p&gt;示例1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中位值为： 2.0&lt;br /&gt;
示例2：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;中位值： (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;题目的意思是将两个数组合并后，如果是奇数个，就返回中间的那个值，如果是偶数个，就返回中间两个数的平均值&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;合并的解决的方式&lt;/p&gt;

    &lt;p&gt;首先想到的时候合并的方式解决，其原理就是合并两个数组，算出中位值，其运行时间为O((m+n)/2) .&lt;br /&gt;
 但是不能满足题目运行时间要求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式解决&lt;/p&gt;

    &lt;p&gt;这种方式是在讨论区发现的。具体实现的原理：寻找数组中第 k(k=（m+n）/ 2+1)个最小的数字.&lt;br /&gt;
 将nums1[k] 和 nums2[k] 进行比较，会有三种情况：&lt;br /&gt;
 如果nums1[k] == nums2[k] 那么这个值就是要找的值。&lt;br /&gt;
 如果nums1[k] &amp;lt; nums2[k],那么第k个数值，必定出现在nums1[ (k+1) ~ m ] 和 nums2[ 0 ~ (k - 1)] 区间中&lt;br /&gt;
 如果nums1[k] &amp;gt; nums2[k],那么第k个数值，必定出现在nums1[ 0 ~ (k - 1)] 和 nums2[ (k+1) ~ n ] 区间中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/7/16.
 */
public class MedianTwoSortedArrays_4 {

    /**
     * 通过合并的方式进行字符串处理.
     */
    public static double findMedianSortedArraysByMerge(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;
        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        int num = 0, firstNum = 0;
        int n1 = 0, n2 = 0, index = 1;
        while (true){
            if (n1 &amp;lt; nums1.length){
                if (n2 &amp;lt; nums2.length){
                    if(nums1[n1] &amp;gt; nums2[n2]){
                        num = nums2[n2++];
                    }else{
                        num = nums1[n1++];
                    }
                }else{
                    num = nums1[n1++];
                }
            }else{
                num = nums2[n2++];
            }

            if (index == leftMedian &amp;amp;&amp;amp; rightMedian == leftMedian){
                return num;
            }else if (index == leftMedian &amp;amp;&amp;amp; rightMedian != leftMedian){
                firstNum = num;
            }else if (index == rightMedian){
                return (firstNum + num)/2.0;
            }

            index++;
        }
    }

    /**
     * 通过递归的方式实现.
     * @param nums1
     * @param nums2
     * @return
     */
    public static double findMedianSortedArraysByRecursive(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;

        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        if (rightMedian != leftMedian){
            return (getMedianNum(nums1,0,nums2,0,leftMedian)+ getMedianNum(nums1,0,nums2,0,rightMedian))/2.0;
        }else{
            return getMedianNum(nums1,0,nums2,0,leftMedian);
        }
    }

    public static double getMedianNum(int[] nums1, int start1, int[]nums2, int start2, int index){
        if(start1 &amp;gt; nums1.length-1) return nums2[start2+index-1];
        if(start2 &amp;gt; nums2.length-1) return nums1[start1+index-1];
        if(index == 1) return Math.min(nums1[start1],nums2[start2]);

        if(start2+index/2-1 &amp;gt; nums2.length-1){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        } 
        if(start1+index/2-1 &amp;gt; nums1.length-1){
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        } 

        if(nums1[start1+index/2-1] &amp;lt; nums2[start2+index/2-1]){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        }else{
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        }
    }

    public static void main(String[] args){
        int[] nums1 = {1,3};
        int[] nums2 = {2};

//        int[] nums1 = {1,3};
//        int[] nums2 = {2};
        long startTime = System.nanoTime();
        double median = findMedianSortedArraysByMerge(nums1, nums2);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
        
        startTime = System.nanoTime();
        median = findMedianSortedArraysByRecursive(nums1, nums2);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>3-Longest Substring Without Repeating Characters</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;&quot;abcabcbb&quot;&lt;/code&gt;, the answer is &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, which the length is 3.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;&quot;bbbbb&quot;,&lt;/code&gt; the answer is &lt;code&gt;&quot;b&quot;&lt;/code&gt;, with the length of 1.&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;&quot;pwwkew&quot;&lt;/code&gt;, the answer is &lt;code&gt;&quot;wke&quot;&lt;/code&gt;, with the length of 3. Note that the answer must be a substring, &lt;code&gt;&quot;pwke&quot;&lt;/code&gt; is a subsequence and not a substring.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;获取一个字符串的各个字符都不相同的子串的最大长度。&lt;br /&gt;
举例：&lt;/p&gt;

&lt;p&gt;字符串 &lt;code&gt;&quot;abcabcbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code&gt;&quot;abc&quot;&lt;/code&gt;, 其长度为 &lt;code&gt;3&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code&gt;&quot;bbbbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code&gt;&quot;b&quot;&lt;/code&gt;, 其长度为 &lt;code&gt;1&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code&gt;&quot;pwwkew&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code&gt;&quot;wke&quot;&lt;/code&gt;, 其长度为 &lt;code&gt;3&lt;/code&gt;. &lt;br /&gt;
注意结果必须为连续的子串， 其中&lt;code&gt;&quot;pwke&quot;&lt;/code&gt;是不同的字符组合，但不是连续的子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;首先要明白这道题目是要获取字符串中不同字符字符组成的子串的最大长度，而不是不同字符的个数。&lt;br /&gt;
声明一个变量start,记录不同字符串的初始索引，一个变量mxlen 记录最大程度，然后遍历字串中字符，记录该字符的索引index，并且查询该字符上次出现的索引位置，如果该字符存在上次索引LastIndex，并且该索引值不小于 start，那么将index 减去 start当做该不同字符子串的长度与maxlen，比较取其大着。通过将LastIndex赋值与start。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 8/6/16.
 * 获取字符串中不重复的字字符串的最大长度.
 */
public class LongSubNoRepeatCHar_3 {

    public static int lengthOfLongestSubstringByMap(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            if (map.get(s.charAt(i)) != null){
                int j = map.get(s.charAt(i));
                if (j &amp;gt;= start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = j + 1;
                    map.remove(s.charAt(i));
                }
            }

            map.put(s.charAt(i), i);
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static int lengthOfLongestSubstringByArray(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        int[] chars = new int[256];
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            int ch = s.charAt(i);
            if (chars[ch] != 0){
                if (chars[ch] &amp;gt; start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = chars[ch];
                }
            }

            chars[ch] = i + 1;
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static void main(String[] args){
        //String str = &quot;abcabcbb&quot;;
        //String str = &quot;aaa&quot;;
        //String str = &quot;pwwkew&quot;;
        // String str = &quot;au&quot;;
        String str = &quot;aab&quot;;
        long startTime = System.nanoTime();
        int length = lengthOfLongestSubstringByMap(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);

        startTime = System.nanoTime();
        length = lengthOfLongestSubstringByArray(str);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//
// Created by yumodev on 8/6/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() == 0) {
            return 0;
        }

        int chars[128];
        memset(chars, 0xff, 128 * sizeof(int));
        int maxLen = 1;
        int start = 0;
        for (int i = 0; i &amp;lt; s.size(); ++i) {
            if (chars[s[i]] != 0 &amp;amp;&amp;amp; chars[s[i]] &amp;gt; start) {
//                if(i - start &amp;gt; maxLen){
//                    maxLen = i - start;
//                }

                maxLen = i - start &amp;gt; maxLen ? i - start : maxLen;
                start = chars[s[i]];
            }

            chars[s[i]] = i + 1;
        }

        if (s.length() - start &amp;gt; maxLen) {
            maxLen = s.length() - start;
        }

        return maxLen;
    }
};

int main() {
   // string str = &quot;auu&quot;;
    string str = &quot;dvdf&quot;;
    //string str = &quot;aaa&quot;;
    //string str = &quot;pwwkew&quot;;
    // string str = &quot;au&quot;;
    //string str = &quot;aab&quot;;
    clock_t start, finish;
    Solution su;
    start = clock();
    int len = su.lengthOfLongestSubstring(str);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot;  len &quot; &amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-javascript&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  if (s === undefined || s.length === 0) {
   return 0;
 }
 var chars = {};
 var maxLen = 1;
 var start = 0;
 for(i = 0; i &amp;lt; s.length; i++){
   if (chars[s[i]] !== undefined) {
      if (chars[s[i]] &amp;gt;= start) {
        if(i - start &amp;gt; maxLen){
          maxLen = i - start;
        }
        start = chars[s[i]];
      }
   }

   chars[s[i]] = i + 1;
 }

 if(s.length - start &amp;gt; maxLen){
   maxLen = s.length - start;
 }

 return maxLen;
};
//var str = &quot;auu&quot;;
var str = &quot;dvdf&quot;
var len = lengthOfLongestSubstring(str);
console.log(num+&quot; &quot;+len);
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>2-Add Two Numbers</title>
        <link>http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</guid>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;题目原地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给出两个标识非负整数的链表，整数在链表中反向存储且链表中的每个节点只存储一个数字。&lt;br /&gt;
将两个整数链表相加，将结果用链表返回&lt;br /&gt;
输入: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
输出: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个简单的问题，只是稍微注意下两个链表长度不一致就可以了。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Created by wks on 8/5/16.
 * You are given two linked lists representing two non-negative numbers.
 * The digits are stored in reverse order and each of their nodes contain a single digit.
 * Add the two numbers and return it as a linked list.
 * &amp;lt;p&amp;gt;
 * Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
 * Output: 7 -&amp;gt; 0 -&amp;gt; 8
 */
public class AddTwoNumbers_2 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int lso = 0;
        int sum = 0;
        ListNode ls = null;
        ListNode nextLn = null;
        while (l1 != null || l2 != null || lso != 0) {
            sum = lso;
            if (l1 != null) sum += l1.val;
            if (l2 != null) sum += l2.val;

            lso = sum / 10;
            ListNode temp = new ListNode(sum % 10);
            if (ls == null) nextLn = ls = temp;
            else{
                nextLn.next = temp;
                nextLn = nextLn.next;
            }

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return ls;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(1027633061);
        ListNode l2 = initListNode(1696698036);
//
//        ListNode l1 = initListNode(342);
//        ListNode l2 = initListNode(465);

//        ListNode l1 = initListNode(5);
//        ListNode l2 = initListNode(5);
        System.out.println(&quot;listNode1 &quot; + ListNodeToString(l1));

        System.out.println(&quot;listNode2 &quot; + ListNodeToString(l2));

        ListNode ls = addTwoNumbers(l1, l2);
        System.out.println(&quot;listNodes &quot; + ListNodeToString(ls));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;//
// Created by yumo on 8/5/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;

struct ListNode
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) { }
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int lso = 0;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while (true){
            int sum = lso;
            if(l1 != NULL){
                sum += l1-&amp;gt;val;
                l1 = l1-&amp;gt;next;
            }
            if(l2 != NULL){
                sum += l2-&amp;gt;val;
                l2 = l2-&amp;gt;next;
            }
            lso = sum /10;
            ListNode* node = new ListNode(sum %10);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }

            if(l1 == NULL &amp;amp;&amp;amp; l2 == NULL &amp;amp;&amp;amp; lso == 0){
                break;
            }
        }

        return ln;
    }

    ListNode* initListNode(int num){
        int mod = 0;
        int temp = num;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while(num  &amp;gt; 0){
            mod = num % 10;
            num = num / 10;
            ListNode* node = new ListNode(mod);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }
        }
        return ln;
    }

    string listNodeToString(ListNode *ln){
        ListNode* next = ln;
        string sb;
        while(next != NULL){
            int val = next-&amp;gt;val;
            next = next-&amp;gt;next;
            sb += to_string(val)+&quot; &quot;;
        }
        return sb;
    }
};

int main()
{
//     int num1 = 342;
//     int num2 = 465;

//    int num1 = 5;
//    int num2 = 5;

      int num1 = 1027633061;
      int num2 = 1696698036;
     Solution solution;

     ListNode* l1 = solution.initListNode(num1);
     ListNode* l2 = solution.initListNode(num2);

     cout&amp;lt;&amp;lt;&quot;l1 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l1)&amp;lt;&amp;lt;endl;
     cout&amp;lt;&amp;lt;&quot;l2 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l2)&amp;lt;&amp;lt;endl;


    clock_t start, finish;

    start = clock();
    ListNode* ln = solution.addTwoNumbers(l1, l2);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot; &amp;lt;&amp;lt; ((double) (finish - start) / CLOCKS_PER_SEC) * 1000000 &amp;lt;&amp;lt;&quot;result: &quot;&amp;lt;&amp;lt;solution.listNodeToString(ln) &amp;lt;&amp;lt; endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-JavaScript&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function ListNode(val) {
     this.val = val;
     this.next = null;
}

function initListNode(num){
   var mod = 0;
   var ln = null;
   var nextLn = null;
   while(num &amp;gt; 0){
      mod = num % 10;
      num = parseInt(num / 10);
      if(ln == null){
        ln = new ListNode(mod);
        nextLn = ln;
      }else{
        nextLn.next = new ListNode(mod);
        nextLn = nextLn.next;
      }
   }

   return ln;
}

function listNodeToString(ln){
  var str =&quot;&quot;;
  var next = ln;
  while(next != null){
    str += next.val+&quot; &quot;;
    next = next.next;
  }
  return str;
}

var addTwoNumbers = function(l1, l2) {
    var los = 0;
    var ln = null;
    var nextLn = null;
    while(true){
      var sum = los;
      if(l1 != null){
        sum += l1.val;
        l1 = l1.next;
      }

      if(l2 != null){
        sum += l2.val;
        l2 = l2.next;
      }
      if(ln == null){
        nextLn = ln = new ListNode(sum % 10);
      }else{
        nextLn.next = new ListNode(sum % 10);
        nextLn = nextLn.next;
      }

      los = parseInt(sum / 10);
      if(l1 == null &amp;amp;&amp;amp; l2 == null &amp;amp;&amp;amp; los == 0){
         break;
      }
    }

    return ln;
};

// var num1 = 342;
// var num2 = 465;

var num1 = 5;
var num2 = 5;

// var num1 = 342;
// var num2 = 465;

var l1 = initListNode(num1);
var l2 = initListNode(num2);
console.log(&quot;l1:&quot;+listNodeToString(l1));
console.log(&quot;l2:&quot;+listNodeToString(l2));
var ln = addTwoNumbers(l1, l2);
console.log(&quot;result:&quot;+listNodeToString(ln));

&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Ubuntu 安装 Tomcat</title>
        <link>http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</guid>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;jdk&quot;&gt;安装JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从官网下载JDK，下载路径 http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.tar.gz&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code&gt;jdk-8u101-linux-x64.tar.gz&lt;/code&gt; 移动到 &lt;code&gt;/usr/lib&lt;/code&gt; 中， 解压到 &lt;code&gt;/usr/lib/jvm &lt;/code&gt;目录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;mkdir jvm
sudo tar -zxvf jdk-8u101-linux-x64.tar.gz -C /usr/lib/jvm
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;jre&quot;&gt;配置JRE路径&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开环境变量文件 &lt;code&gt;sudo vi ~/.bashrc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在文件的末尾添加下面内容&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_101
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH  
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jre-1&quot;&gt;测试JRE&lt;/h3&gt;

&lt;p&gt;通过 &lt;code&gt;java -version&lt;/code&gt;  查看当前的Java路径&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;java version &quot;1.8.0_101&quot;
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;安装tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载tomcat 下载地址：http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M9/bin/apache-tomcat-9.0.0.M9.zip&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将文件移动到 /usr/local 目录下，解压命名为 tomcat9&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;  cp apache-tomcat-9.0.0.M9.zip /usr/local
  uzip apache-tomcat-9.0.0.M9.zip
  mv apache-tomcat-9.0.0.M9 tomcat9
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;启动tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;开启tomcat9 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;sudo chomd 755 /usr/local/tomcat9/bin/*.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;启动tomcat&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local/tomcat9/bin
./startup.sh

Using CATALINA_BASE:   /usr/local/tomcat9
Using CATALINA_HOME:   /usr/local/tomcat9
Using CATALINA_TMPDIR: /usr/local/tomcat9/temp
Using JRE_HOME:        /usr/lib/jvm/jdk1.8.0_101/jre
Using CLASSPATH:       /usr/local/tomcat9/bin/bootstrap.jar:/usr/local/tomcat9/bin/tomcat-juli.jar
Tomcat started.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;测试访问&lt;/h3&gt;

&lt;p&gt;在浏览器中输入 &lt;code&gt;http://localhost:8080&lt;/code&gt; 访问&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>比较两个字符串排序后是否相等</title>
        <link>http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;比较两个字符串排序后是否相等&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;首先比较字符串的长度，长度不相等的字符串，即使排序后也是不相等。&lt;br /&gt;
如果两个字符串长度相符，那么有下面两种方法进行比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让两个字符串分别排序后进行比较&lt;/li&gt;
  &lt;li&gt;比较两个字符串中的每个字符的数量是否相等
    &lt;ol&gt;
      &lt;li&gt;将字符和字符的数量当做Map的key和value，然后分别比较。&lt;/li&gt;
      &lt;li&gt;如果字符串是Ascii编码，那么可以将字符的数量直接放到数组进行优化。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例(Java)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 比较两个字符排序后是否相等
 */
public class StringIsSameAfterSort {


    private static String sort(String str){
        char[] chArr = str.toCharArray();
        Arrays.sort(chArr);
        return new String(chArr);
    }

    /**
     * 通过Arrays.sort进行比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByArraysSort(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        return sort(str1).equals(sort(str2));
    }

    private static Map convertMapNums(String str){
        Map&amp;lt;Character, Integer&amp;gt; map= new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;  str.length(); i++){
            char c = str.charAt(i);
            if (map.get(c) == null){
                map.put(c,  1);
            }else{
                map.put(c,  map.get(c)+1);
            }
        }

        return map;
    }

    /**
     * 将两个字符串的字符和数量放入Map中.然后比较Map中每个字符数量是否相等
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNums(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        Map&amp;lt;Character, Integer&amp;gt; map1 = convertMapNums(str1);
        Map&amp;lt;Character, Integer&amp;gt; map2 = convertMapNums(str2);

        if (map1.size() != map2.size()){
            return false;
        }

        boolean isSame = true;
        Set&amp;lt;Character&amp;gt; set1 = map1.keySet();
        for (Character ch: set1) {
            if (map1.get(ch) != map2.get(ch)){
                isSame = false;
                break;
            }
        }

        return isSame;
    }


    /**
     * 如果是Ascii编码,那么不同字符的数量最大为256个,所以可以声明一个长度256的数组,将字符的数量放到这个数组中,然后在一一比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNumsAscii(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        int[] chArr1 = new int[256];
        for (int i = 0; i &amp;lt; str1.length(); i++){
            char ch = str1.charAt(i);
            chArr1[ch] = chArr1[ch]+1;
        }

        int[] chArr2 = new int[256];
        for (int i = 0; i &amp;lt;str2.length(); i++){
            char ch = str2.charAt(i);
            chArr2[ch] = chArr2[ch]+1;
        }

        boolean isSame = true;
        for (int i = 0; i &amp;lt; 256; i++){
            if (chArr1[i] != chArr2[i]){
                isSame = false;
                break;
            }
        }

        return isSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str1=&quot;1234567333&quot;;
        String str2=&quot;7654321333&quot;;

        long startTime = System.nanoTime();
        boolean isSame = isStringEqualByArraysSort(str1, str2);
        long endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByArraysSort: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNums(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNums: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNumsAscii(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNumsAscii: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;效率比较&lt;/h3&gt;

&lt;p&gt;假定这两个字符串的长度为10，那么这三种方法所花费的时间如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;isStringEqualByArraysSort: true time:167000
isStringEqualByCharNums: true time:518000
isStringEqualByCharNumsAscii: true time:29000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果能够确定字符串中的字符数量，不是太大的话，优先采用利用数组统计字符数量的方法才是效率最高的。&lt;br /&gt;
不过在工作中直接使用数组排序的解决方式是优先考虑的选择&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>反转一个字符串</title>
        <link>http://disheng54.github.io/2016/07/31/string-ReverseString.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-ReverseString.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;将一个字符串反转&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个常见的问题，在实际的开发中也经常用到，解决的方法有很多种。我使用下面四种方法进行，并且最后比较其中的效率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;利用系统自带的StringBuilder.reverse()  进行反转。&lt;/li&gt;
  &lt;li&gt;使用将字符串转换为字符数据，然后进行二分反转。&lt;/li&gt;
  &lt;li&gt;使用字符的异或进行转换。&lt;/li&gt;
  &lt;li&gt;使用Stack数据结构进行反转。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
     * 利用系统自带的StringBuilder.reverse() 进行反转
     * @param str
     * @return
     */
    public static String reverseByStringBuilder(String str){
        if (str == null){
            return &quot;&quot;;
        }
        return new StringBuilder(str).reverse().toString();
    }

    /**
     * 使用字符串进行二分反转
     * @return
     */
    public static String reverseByCharArray(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length;
        for (int i = (len-1) / 2; i &amp;gt;= 0; i--){
            char c = chArr[i];
            chArr[i] = chArr[len - i -1];
            chArr[len - i -1] = c;
        }

        return new String(chArr);
    }

    /**
     * 使用异或进行翻转
     * 将二进制 a = 1101, b = 1000 进行反转.
     * 1  a = 1101 ^ 1000 此时 a = 1010, b = 1000
     * 2  b = 1000 ^ 1010 此时 a = 1010, b = 1101
     * 3  a = 1101 ^ 1010 此时 a = 1000, b = 1101
     * @return
     */
    public static String reverseByXor(String str){
        if (str == null){
            return &quot;&quot;;
        }

        char[] chArr = str.toCharArray();
        int len = chArr.length ;
        for (int i = 0, j = len -1; i &amp;lt; len/2; i++, j--){
            chArr[i] = (char)(chArr[i]^chArr[j]);
            chArr[j] = (char)(chArr[j]^chArr[i]);
            chArr[i] = (char)(chArr[j]^chArr[i]);
        }

        return new String(chArr);
    }

    /**
     * 使用栈进行翻转
     * @param str
     * @return
     */
    public static String reverseByStack(String str){
        if (str == null){
            return &quot;&quot;;
        }

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        int len = str.length();
        for (int i = 0; i &amp;lt; len; i++){
            stack.push(str.charAt(i));
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &amp;lt; len; i++){
            sb.append(stack.pop());
        }
        return sb.toString();
    }



    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str=&quot;&quot;;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i&amp;lt;= 10000; i++){
            sb.append(i+&quot;&quot;);
        }
        str = sb.toString();


        long startTime = System.nanoTime();
        String str1 = reverseByStringBuilder(str);
        long endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    StringBuilder.reverse(): &quot;+str1);


        startTime = System.nanoTime();
        str1 = reverseByCharArray(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByCharArray: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByXor(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByXor: &quot;+str1);

        startTime = System.nanoTime();
        str1 = reverseByStack(str);
        endTime = System.nanoTime();
        System.out.println(&quot; time:&quot;+(endTime - startTime)+&quot;    reverseByStack: &quot;+str1);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;效率比较 单位是纳秒&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10的字符串进行反转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  StringBuilder.reverse() time:14000  
  reverseByCharArray time:7000 
  reverseByXor time:4000 
  reverseBystack time:315000 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为100的字符串进行反转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  StringBuilder.reverse() time:29000  
  reverseByCharArray time:11000 
  reverseByXor time:9000 
  reverseBystack time:589000 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为1000的字符串进行反转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  StringBuilder.reverse() time:295000 
  reverseByCharArray time:72000 
  reverseByXor time:76000
  reverseBystack time:3949000
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对长度为10000的字符串进行反转&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  StringBuilder.reverse() time:3321000
  reverseByCharArray time:966000 
  reverseByXor time:1421000
  reverseBystack time:18414000 
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;结果比较&lt;/p&gt;

    &lt;p&gt;在字符串较短的情况下通过异或反转所用的时间是最短的，二分数组仅次之。&lt;br /&gt;
 在字符串较长的情况下使用二分数组的是花费时间最短的。&lt;br /&gt;
 使用栈进行反转花费的时间时间最长是二分数组反转的两个数量级。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>判断一个字符串里面的字符都是不相同的</title>
        <link>http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-AnalyzingStringsNoSame.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;

&lt;p&gt;判断一个字符串里面的字符都是不相同的。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个问题有很多种解决方案，并且可以根据字符串字符集的不同，可以做不同的优化。有下面几种解决问题的思路&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;遍历字符串中的字符与字符串中的其他的字符比较。&lt;/li&gt;
  &lt;li&gt;可以将字符串进行排序，然后比较相邻的字符是否相等。&lt;/li&gt;
  &lt;li&gt;可以利用String方法的lastIndexOf() 方法进行比较。这个方法原理同上。&lt;/li&gt;
  &lt;li&gt;可以借助第三方的数据结构进行，比如Set，List， Map等等。&lt;/li&gt;
  &lt;li&gt;如果是ASCII字符集，那么通过构建一个长度为256默认为false的布尔数组，存在的字符设置为true，将该索引位置第二次设置为true时，就标志着有相同的字符。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实例代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 实现一个算法,判断一个字符串中的所有字符是否全都不同.
 */
public class AnalyzingStringsNoSame {
    private static final String LOG_TAG = &quot;AnalyzingStringsNoSame&quot;;

    /**
     * 将字符串里面的字符取出放入到set中, 如果add 返回false,即认为有相同的字符
     * @param str
     * @return
     */
    public static boolean isSameBySet(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;
        Set&amp;lt;Character&amp;gt; set = new HashSet&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; str.length(); i++){
            if(!set.add(str.charAt(i))){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }


    /**
     * 利用String 的 lastIndexOf(int) 来查找
     * @param str
     * @return
     */
    public static boolean isSameByIndex(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            if(str.lastIndexOf(str.charAt(i)) != i){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 将字符串里面的字符和其他的字符串进行比较
     * @param str
     * @return
     */
    public static boolean isSameByTraverse(String str){
        if (str == null){
            return false;
        }

        boolean noSame = true;

        for (int i = 0; i &amp;lt; str.length(); i++){
            int ca = str.charAt(i);
            for (int j = i+1; j &amp;lt; str.length(); j++){
                if (ca == str.charAt(j)){
                    noSame = false;
                    break;
                }
            }
        }
        return !noSame;
    }


    /**
     * 将字符串排序,然后比较相邻的字符是否相等.
     * @param str
     * @return
     */
    public static boolean isSameBySort(String str){
        if (str == null){
            return false;
        }

        char[] caArr = str.toCharArray();
        Arrays.sort(caArr);

        boolean noSame = true;
        for (int i = 0; i &amp;lt; caArr.length-1;){
            if (caArr[i] == caArr[++i]){
                noSame = false;
                break;
            }
        }
        return !noSame;
    }

    /**
     * 如果字符串的为ASCII编码,如果字符串的长度大于256,就肯定存在相同的字符.
     * @param str
     * @return
     */
    public static boolean isAsciiSame(String str){
        if (str == null){
            return false;
        }

        if (str.length() &amp;gt; 256){
            return true;
        }

        boolean[] caArr = new boolean[256];

        boolean noSame = true;
        for (int i = 0; i &amp;lt; str.length(); i++){
            int ch = str.charAt(i);
            if (caArr[ch]){
                noSame = false;
                break;
            }
            caArr[ch] = true;
        }
        return !noSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str = &quot;15234d&quot;;
        System.out.println(&quot;字符串:&quot;+str);
        System.out.println(&quot;isSameBySet: &quot;+AnalyzingStringsNoSame.isSameBySet(str));
        System.out.println(&quot;isSameByIndex: &quot;+AnalyzingStringsNoSame.isSameByIndex(str));
        System.out.println(&quot;isSameByTraverse: &quot;+AnalyzingStringsNoSame.isSameByTraverse(str));
        System.out.println(&quot;isSameBySort: &quot;+AnalyzingStringsNoSame.isSameBySort(str));
        System.out.println(&quot;isAsciiSame: &quot;+AnalyzingStringsNoSame.isAsciiSame(str));
    }
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>1-Two Sum</title>
        <link>http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/leetcode-TowNum.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;原链接:&lt;a href=&quot;https://leetcode.com/problems/two-sum/&quot;&gt;Two Sum&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;
&lt;p&gt;Given an array of integers, return indices of the two numbers such that they add up to a specific target.&lt;br /&gt;
You may assume that each input would have exactly one solution.&lt;br /&gt;
Example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个整型数组，如果该数组中有两个数值的和等于一个特定值，就返回这两个数值在数组中的索引。&lt;br /&gt;
假定有唯一的解决方案。&lt;br /&gt;
示例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Given nums = [2, 7, 11, 15], target = 9,
Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;假定有一个Map，遍历寻找&lt;code&gt;target-nums[n] &lt;/code&gt;为key对应的value，如果找不到就将nums[n]和索引n作为存放于Map中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;示例代码-Java&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 7/31/16.
 * Given an array of integers, return indices of the two numbers such that they add up to a specific target.

 You may assume that each input would have exactly one solution.

 Example:
 Given nums = [2, 7, 11, 15], target = 9,

 Because nums[0] + nums[1] = 2 + 7 = 9,
 return [0, 1].
 */
public class TwoSum_1 {
    /**
     * 通过hashMap实现
     * @param nums
     * @param target
     * @return
     */
    public static int[] twoSumByHashMap(int[] nums, int target){
        int[] result = new int[2];
        Map&amp;lt;Integer, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt; nums.length; i++){
            if(map.get(target - nums[i]) != null){
                result[0] = map.get(target - nums[i]);
                result[1] = i;
                break;
            }

            map.put(nums[i], i);
        }
        return result;
    }

    public static void main(String[] args){
        int[] nums = {2,7,11,15};
        int target = 9;
        
        long startTime = System.nanoTime();
        int[] result = twoSumByHashMap(nums, target);
        long endTime = System.nanoTime();
        System.out.println(String.format(&quot;time :&quot; + (endTime - startTime)+&quot; [%d, %d]&quot;, result[0], result[1]));
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;c&quot;&gt;示例代码-c++&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;map&amp;gt;


using namespace std;

vector&amp;lt;int&amp;gt; twoSumByArraySort(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target)
{
    map&amp;lt;int, int&amp;gt; ht;
    for (int i = 0; i &amp;lt; nums.size(); i++) {
        ht.insert(map&amp;lt;int,int&amp;gt;::value_type(nums[i], i));
    }
    vector&amp;lt;int&amp;gt; res(2, -1);
    sort(nums.begin(), nums.end());
    int begin = 0;
    int end = nums.size() -1;

    while(begin &amp;lt; end){
        if(nums[begin] + nums[end] == target){
            res[0] = min(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            res[1] = max(ht.find(nums[begin])-&amp;gt;second, ht.find(nums[end])-&amp;gt;second);
            break;
        }else if (nums[begin] + nums[end] &amp;lt; target){
            begin ++;
        }else {
            end --;
        }
    }
    return res;
}

int main() {
    vector&amp;lt;int&amp;gt; nums = {2,7,11,15};
    int target = 9;

    clock_t start, finish;

    start = clock();
    vector&amp;lt;int&amp;gt; result = twoSumByMap(nums, target);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot; twoSumByMap:&quot; &amp;lt;&amp;lt;&quot;[&quot;&amp;lt;&amp;lt;result[0]&amp;lt;&amp;lt;&quot;,&quot;&amp;lt;&amp;lt;result[1]&amp;lt;&amp;lt;&quot;]&quot;&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;javascript&quot;&gt;示例代码-JavaScript&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var twoSumByMap = function(nums, target) {
    var map = {};
    for(var i in nums){
      if(map[target-nums[i]] !== undefined){
        return [parseInt(map[target-nums[i]]),parseInt(i)];
      }else{
      map[nums[i]] = i;
      }
    }
};

var nums = [0,4,3,0];
var target = 0;
var beginTime = new Date().getTime();
var result = twoSumByMap(nums, target);
var endTime = new Date().getTime();
console.log(&quot;Time:&quot;+(endTime - beginTime)+&quot; result:&quot;+result);
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
  </channel>
</rss>