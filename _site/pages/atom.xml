<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>禹墨的博客</title>
    <link>http://disheng54.github.io</link>
    <description>禹墨的博客</description>
    
      <item>
        <title>Adb常用命令</title>
        <link>http://disheng54.github.io/2017/09/14/android-adb.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2017/09/14/android-adb.html</guid>
        <pubDate>Thu, 14 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;Adb 常用命令 &lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;基础命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看版本信息:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb version&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看帮助:&lt;code class=&quot;highlighter-rouge&quot;&gt; adb -h&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进入shell: &lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;退出shell: &lt;code class=&quot;highlighter-rouge&quot;&gt;exit&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;重启设备:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb reboot&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;终止adb服务:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb kill-server&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;启动adb服务:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb start-server&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-1&quot;&gt;文件操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;adb pull &lt;remote&gt; &lt;local&gt; 命令从真机拷贝文件到pc上。&lt;/local&gt;&lt;/remote&gt;&lt;/li&gt;
  &lt;li&gt;adb push &lt;local&gt; &lt;remote&gt; 命令从pc上复制一份文件到真机上。&lt;/remote&gt;&lt;/local&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;截屏&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell screencap -p /sdcard/screen.png
adb pull /sdcard/screen.png
adb shell rm /sdcard/screen.png
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-3&quot;&gt;设备相关&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看设备序列号&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb get-serialno&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取CPU信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell cat /proc/cpuinfo&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看设备的内存信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell cat /proc/meminfo&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取设备名称&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell cat /system/build.prop&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取设备分辨率&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell wm size&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apk&quot;&gt;安装APK&lt;/h2&gt;

&lt;h3 id=&quot;apk-1&quot;&gt;安装APK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;安装apk:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb install &amp;lt;apkfile&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;强制安装apk: &lt;code class=&quot;highlighter-rouge&quot;&gt;adb install -r &amp;lt;apkfile&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;安装apk到Sd卡: &lt;code class=&quot;highlighter-rouge&quot;&gt;adb install -s &amp;lt;apkfile&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app&quot;&gt;卸载APP&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;卸载APP:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb uninstall &amp;lt;packagename&amp;gt;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;卸载APP但是保留文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;adb uninstall -k &amp;lt;package&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pm-&quot;&gt;pm 命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;查看pm命令帮助： &lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell cmd package&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-4&quot;&gt;打印应用列表&lt;/h3&gt;

&lt;p&gt;查看应用列表的格式：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]&lt;/code&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;参数&lt;/th&gt;
      &lt;th&gt;含义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;-f&lt;/td&gt;
      &lt;td&gt;see their associated file&lt;br /&gt;显示关联的APK文件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-d&lt;/td&gt;
      &lt;td&gt;filter to only show disabled packages&lt;br /&gt;只显示禁用的包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-e&lt;/td&gt;
      &lt;td&gt;filter to only show enabled packages&lt;br /&gt;只显示启用的包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-s&lt;/td&gt;
      &lt;td&gt;filter to only show system packages&lt;br /&gt;只显示系统的包名&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-3&lt;/td&gt;
      &lt;td&gt;filter to only show third party packages&lt;br /&gt;只显示第三方安装的包&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-i&lt;/td&gt;
      &lt;td&gt;see the installer for the packages&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;-u&lt;/td&gt;
      &lt;td&gt;also include uninstalled packages&lt;br /&gt;显示已卸载的应用&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;打印所有的包名:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell pm list packages &lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查看包名某一个字符串的包名&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell pm list packages com.taobao.taobao
adb shell pm list packages | grep com.taobao.taobao
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-5&quot;&gt;清除应用数据和缓存&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;adb shell pm clear &amp;lt;包名&amp;gt;
adb shell pm clear com.taobao.taobao
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;am-&quot;&gt;am 命令&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;启动Activity&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell am start -n &amp;lt;package_name&amp;gt;/.&amp;lt;activity_class_name&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dumpsys-&quot;&gt;dumpsys 打印服务信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;输出系统正在运行的所有服务:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys -l&lt;/code&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打印系统中的服务某个服务的信息:&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys &amp;lt;服务名&amp;gt;&lt;/code&gt; 命令&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;activity&quot;&gt;activity相关的信息&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看前台Activty&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity activities | grep mFocusedActivity&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看顶部的Activity&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity top&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看所有正在运行的服务&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity services &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过字符串过滤正则运行的服务&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity services  &amp;lt;过滤字符串&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;显示待处理的Intent&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity intents&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看provider信息&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; adb shell dumpsys activity providers
 adb shell dumpsys activity prov
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;cpu&quot;&gt;进程、CPU、内存信息&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;cpu信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys cupinfo&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打印内存信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys meminfo&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cpu-top&quot;&gt;打印进程、CPU、内存信息-top命令&lt;/h3&gt;

&lt;p&gt;-t 显示进程名称，-s 按指定行排序，-n 在退出前刷新几次，-d 刷新间隔，-m 显示最大数量&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看内存和cpu信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell top&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;制定进程数量&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell top -m 1&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;刷新进程数据次数&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell top -n 5&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ps&quot;&gt;ps命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查看进程状态&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell ps&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看指定id进程信息&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell ps &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;筛选进程信息，或者查看一个包下的进程。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell ps | grep &amp;lt;字符串&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;杀死一个进程&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell kill &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-6&quot;&gt;其他&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;生成bug报告&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;adb bugreport&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-7&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/studio/command-line/adb.html&quot;&gt;Android 调试桥&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/0693b841c83b&quot;&gt;开发必备—你应该知道的一些 ADB 命令&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.csdn.net/zhangjg_blog/article/details/39852309&quot;&gt;android中dumpsys命令用法详解&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2016/05/14/dumpsys-command/&quot;&gt;dumpsys命令用法&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gityuan.com/2017/07/04/ams_dumpsys/&quot;&gt;AMS之dumpsys篇&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>LinkedHashMap的使用以及LRU算法的实现</title>
        <link>http://disheng54.github.io/2017/09/10/java-linkedhashmap-lru.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2017/09/10/java-linkedhashmap-lru.html</guid>
        <pubDate>Sun, 10 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;linkedhashmaplru&quot;&gt;LinkedHashMap的使用以及LRU算法的实现&lt;/h1&gt;

&lt;h2 id=&quot;linkedhashmap&quot;&gt;什么是LinkedHashMap&lt;/h2&gt;

&lt;p&gt;LinkedHashMap是HashMap的子类，能够记住插入数据的顺序，由于HashMap并不能保证插入数据的顺序，如果我们需要记住插入的顺序的就需要使用LinkedHashMap.&lt;/p&gt;

&lt;h2 id=&quot;linkedhashmap-1&quot;&gt;LinkedHashMap的顺序&lt;/h2&gt;

&lt;p&gt;LinkedHashMap提供两种数据排序的方式，一种是按照插入顺序进行排序，一种按照访问顺序进行排序。&lt;/p&gt;

&lt;p&gt;在LinkedHashMap中定义了变量&lt;code class=&quot;highlighter-rouge&quot;&gt;final boolean accessOrder;&lt;/code&gt;来标记使用哪种访问方式。由于是final类型的变量，所以它只能在构造方法中赋值，然后就不能再改变数据的排序方式。&lt;/p&gt;

&lt;p&gt;下面是一个例子来演示这两种排序方式。输入输入&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0,0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;9,9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;,然后访问数据，查看数据的排序方式。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;按照插入顺序排序&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  System.out.println(&quot;开始插入顺序的测试&quot;);
   //accessOrder 为true，按照访问顺序排序，false：按照插入顺序排序
   LinkedHashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, false);
   for (int i = 0; i &amp;lt; 10; i ++){
       map.put(i, i);
   }

   System.out.println(map.toString());

   System.out.println(map.get(6));

   System.out.println(map.toString());
   System.out.println(&quot;结束插入顺序的测试&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0=0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1=1,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2=2,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;3=3,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;4=4,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;5=5,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;6=6,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;7=7,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;8=8,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;9=9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0=0,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1=1,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2=2,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;3=3,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;4=4,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;5=5,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;6=6,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;7=7,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;8=8,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;9=9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;按照访问顺序排序&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  System.out.println(&quot;开始访问顺序的测试&quot;);
   //accessOrder 为true，按照访问顺序排序，false：按照插入顺序排序
   LinkedHashMap&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, true);
   for (int i = 0; i &amp;lt; 10; i ++){
       map.put(i, i);
   }

   System.out.println(map.toString());

   System.out.println(map.get(6));

   System.out.println(map.toString());
   System.out.println(&quot;结束访问顺序的测试&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;开始访问顺序的测试
{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}
6
{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 6=6}
结束访问顺序的测试
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;lru&quot;&gt;什么是LRU算法&lt;/h2&gt;

&lt;p&gt;LRU是Lease Recently User的缩写，意思是最近 最少使用。比如设计一个文件缓存系统，每个文件有自己的大小和访问时间，文件缓存系统有总的大小，当往这个文件系统中放入新的文件时，如果发现超出文件缓存系统的容量，那么把访问时间最旧的文件删掉。所有定义这样一个文件系统的需要记录文件的访问顺序，而通过上面的例子我们知道LinkedHashMap可以轻松实现这个功能。&lt;/p&gt;

&lt;h2 id=&quot;lru-1&quot;&gt;实现一个最简单的LRU算法&lt;/h2&gt;

&lt;p&gt;这个算法实现最多存放maxSize个数据，当存放数据的个数超出maxSize时，删除最近最少使用的数据。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//map的最大容量是10
final int maxSize = 10;
Map&amp;lt;Integer, Integer&amp;gt; map = new LinkedHashMap&amp;lt;Integer, Integer&amp;gt;(0, 0.75f, true) {
  @Override
  protected boolean removeEldestEntry(Map.Entry&amp;lt;Integer, Integer&amp;gt; eldest) {
      return size() &amp;gt; maxSize;
  }
};

System.out.println(map.size());
for (int i = 0; i &amp;lt; 10; i ++){
  map.put(i, i);
}
System.out.println(&quot;当前有10个数据：&quot;+map.toString());
System.out.println(map.get(6));
System.out.println(&quot;访问key为6的数据后：&quot;+map.toString());
map.put(11,11);
System.out.println(&quot;插入第11个数据后：&quot;+map.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当前有10个数据：{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}
6
访问key为6的数据后：{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 6=6}
插入第11个数据后：{1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 6=6, 11=11}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;lru-2&quot;&gt;实现一个通用的LRU缓存算法。&lt;/h2&gt;

&lt;p&gt;上面的实现的LRU算法中默认的每个数据的大小是为1，如果是文件存储系统，每个文件大小是不一样的，所以一个通用的LRU缓存算法还有提供一个计算数据方法的大小，下面一个最小化的&lt;br /&gt;
通用LRU缓存算法实现，该算法参照了Android中LruCache类的实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class LruCache&amp;lt;K,V&amp;gt; {
    private LinkedHashMap&amp;lt;K,V&amp;gt; map;
    //最大缓存容量
    private int maxSize;
    //当前容量
    private int size;


    public LruCache(int maxSize){
        this.maxSize = maxSize;
        map = new LinkedHashMap&amp;lt;&amp;gt;(0, 0.75f, true);
    }

    /**
     * 插入一条数据，更新当前容量大小，并检测是否已超出容量
     * @param key
     * @param value
     */
    public void put(K key, V value){
        size += sizeOf(key, value);
        map.put(key, value);
        trimSize(maxSize);
    }

    /**
     * 获取一条数据
     * @param key
     * @return
     */
    public V get(K key){
        V v;
        synchronized (this){
            v = map.get(key);
        }
        return v;
    }

    /**
     * 删除一条数据，并更新当前容量
     * @param key
     * @return
     */
    public V remote(K key){
        V v = map.remove(key);
        size -= sizeOf(key, v);
        return v;
    }

    /**
     * 检测当前容量是否已经超过最大容量，如果超过就开始清除数据，知道size小于maxSize为止。
     * @param maxSize
     */
    public void trimSize(int maxSize){
        while (true) {
            K key;
            V value;
            synchronized (this) {
                if (size &amp;lt; 0 || (map.isEmpty() &amp;amp;&amp;amp; size != 0)) {
                    throw new IllegalStateException(getClass().getName()
                            + &quot;.sizeOf() is reporting inconsistent results!&quot;);
                }

                if (size &amp;lt;= maxSize || map.isEmpty()) {
                    break;
                }

                Map.Entry&amp;lt;K, V&amp;gt; toEvict = map.entrySet().iterator().next();
                key = toEvict.getKey();
                value = toEvict.getValue();
                map.remove(key);
                size -= sizeOf(key, value);
            }
        }
    }

    /**
     * 重新调整缓存总大小
     * @param maxSize
     */
    public void resize(int maxSize){
        if (maxSize &amp;lt;= 0){
            throw new IllegalArgumentException(&quot;MaxSize 不能小于等于0！&quot;);
        }
        synchronized (this){
            this.maxSize = maxSize;
        }
        resize(maxSize);
    }

    /**
     * 数据大小.默认为1，想要修改数据大小，还需要子类实现
     * @param key
     * @param value
     * @return
     */
    protected int sizeOf(K key, V value) {
        return 1;
    }

    /**
     * 清除
     * @return
     */
    public void clear(){
        synchronized (this){
            map.clear();
        }
    }

    @Override
    public String toString() {
        return &quot;size:&quot;+size+&quot;;maxSize:&quot;+maxSize+&quot; &quot;+map.toString();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;lrucache&quot;&gt;使用LruCache.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;定义最大容量为10，每个数据的大小为1&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; final int maxSize = 10;
LruCache&amp;lt;Integer,Integer&amp;gt; lruCache = new LruCache&amp;lt;Integer, Integer&amp;gt;(maxSize){
  @Override
  protected int sizeOf(Integer key, Integer value) {
      return 1;//数据大小为1
  }
};

for (int i = 0; i &amp;lt; maxSize; i ++){
  lruCache.put(i, i);
}
System.out.println(&quot;当前数据：&quot;+lruCache.toString());
System.out.println(&quot;key为6的数据&quot;+lruCache.get(6));
System.out.println(&quot;访问key为6的数据后：&quot;+lruCache.toString());
lruCache.put(11,11);
System.out.println(&quot;插入value为11的数据后：&quot;+lruCache.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当前数据：size:10;maxSize:10 {0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}
key为6的数据6
访问key为6的数据后：size:10;maxSize:10 {0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 6=6}
插入value为11的数据后：size:10;maxSize:10 {1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 6=6, 11=11}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;定义最大容量为10，每个数据的大小为2&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; final int maxSize = 10;
LruCache&amp;lt;Integer,Integer&amp;gt; lruCache = new LruCache&amp;lt;Integer, Integer&amp;gt;(maxSize){
  @Override
  protected int sizeOf(Integer key, Integer value) {
      return 1;//数据大小为2
  }
};

for (int i = 0; i &amp;lt; maxSize; i ++){
  lruCache.put(i, i);
}
System.out.println(&quot;当前数据：&quot;+lruCache.toString());
System.out.println(&quot;key为6的数据&quot;+lruCache.get(6));
System.out.println(&quot;访问key为6的数据后：&quot;+lruCache.toString());
lruCache.put(11,11);
System.out.println(&quot;插入value为11的数据后：&quot;+lruCache.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当前数据：size:10;maxSize:10 {5=5, 6=6, 7=7, 8=8, 9=9}
key为6的数据6
访问key为6的数据后：size:10;maxSize:10 {5=5, 7=7, 8=8, 9=9, 6=6}
插入value为11的数据后：size:10;maxSize:10 {7=7, 8=8, 9=9, 6=6, 11=11}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;定义最大容量为10，每个数据的大小为value&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final int maxSize = 10;
LruCache&amp;lt;Integer,Integer&amp;gt; lruCache = new LruCache&amp;lt;Integer, Integer&amp;gt;(maxSize){
  @Override
  protected int sizeOf(Integer key, Integer value) {
      return value;//数据大小为value
  }
};

for (int i = 0; i &amp;lt; maxSize; i ++){
  lruCache.put(i, i);
}
System.out.println(&quot;当前数据：&quot;+lruCache.toString());
System.out.println(&quot;key为6的数据&quot;+lruCache.get(6));
System.out.println(&quot;访问key为6的数据后：&quot;+lruCache.toString());
lruCache.put(11,11);
System.out.println(&quot;插入value为11的数据后：&quot;+lruCache.toString());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当前数据：size:9;maxSize:10 {9=9}
key为6的数据null
访问key为6的数据后：size:9;maxSize:10 {9=9}
插入value为11的数据后：size:0;maxSize:10 {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>分屏模式</title>
        <link>http://disheng54.github.io/2017/09/10/android-multiscreen.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2017/09/10/android-multiscreen.html</guid>
        <pubDate>Sun, 10 Sep 2017 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;section&quot;&gt;分屏模式&lt;/h2&gt;

&lt;p&gt;Android N 添加了对同时显示多个应用窗口的支持。 手机上两个应用可以在“分屏”模式中左右并排或上下并排显示。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;如何进入分屏模式&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;打开App，长按底部Overview按键(底部的正方形按键)&lt;/li&gt;
  &lt;li&gt;在多窗口任务页面，长按App，则可以拖动该 App至屏幕突出显示的区域，使 App 进入分屏模式。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section-2&quot;&gt;开启分屏模式&lt;/h2&gt;

&lt;p&gt;App默认是支持分屏模式的。&lt;br /&gt;
如果App是基于Android N版本编译的，那么通过可以在manifest文件中设置Application或者Activity的属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;android:resizeableActivity=[&quot;true&quot; | &quot;false&quot;]&lt;/code&gt;。如果设置&lt;code class=&quot;highlighter-rouge&quot;&gt;resizeableActivity&lt;/code&gt;属性为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;则支持分屏模式，如果设置&lt;code class=&quot;highlighter-rouge&quot;&gt;resizeableActivity&lt;/code&gt;属性为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;则不支持分屏模式。&lt;/p&gt;

&lt;p&gt;如果App的编译版本低于Android N, 那么当用户尝试进入分屏模式时候，系统会强制将App进入分屏模式。那么在这种情况下，在清单文件中的主Activity中设置&lt;code class=&quot;highlighter-rouge&quot;&gt;android:screenOrientation=&quot;portrait&quot;&lt;/code&gt;属性，就可以禁止进入分屏模式。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;监听是否进入分屏模式&lt;/h2&gt;

&lt;p&gt;Activity 进入或退出分屏模式时系统将调用此方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onMultiWindowModeChanged(boolean isInMultiWindowMode) {
   super.onMultiWindowModeChanged(isInMultiWindowMode);
   Log.i(LOG_TAG,&quot;onMultiWindowModeChanged isInMultiWindowsMode:&quot;+isInMultiWindowMode);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;activity&quot;&gt;进入分屏模式后的Activity的生命周期&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;进入分屏模式后Activity的生命周期的明白，可以看出当前Activity进行了销毁重建。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MainActivity: onMultiWindowModeChanged isInMultiWindowsMode:true
MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onPause
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;退出分屏模式的生命周期&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MainActivity: onPause
MainActivity: onStop
MainActivity: onDestroy
MainActivity: onCreate
MainActivity: onStart
MainActivity: onResume
MainActivity: onPause
MainActivity: onMultiWindowModeChanged isInMultiWindowsMode:true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;activity-1&quot;&gt;在分屏模式中打开新的Activity&lt;/h2&gt;

&lt;p&gt;在启动Activity的时候添加标志Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT,&lt;br /&gt;
如果此时App处于分屏模式，那么新Activity将会在当前Activity的旁边。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intent intent = new Intent(MainActivity.this, TestActivity.class);
intent.setFlags(Intent.FLAG_ACTIVITY_LAUNCH_ADJACENT | Intent.FLAG_ACTIVITY_NEW_TASK);
startActivity(intent);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;section-4&quot;&gt;参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.android.com/guide/topics/ui/multi-window.html&quot;&gt;多窗口支持&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/e6a908d7d5b1&quot;&gt;是时候学习多分屏了&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://unclechen.github.io/2016/03/12/Android%20N%20App%E5%88%86%E5%B1%8F%E6%A8%A1%E5%BC%8F%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E4%B8%8A%E7%AF%87/&quot;&gt;Android N App分屏模式完全解析（上）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://unclechen.github.io/2016/03/12/Android%20N%20App%E5%88%86%E5%B1%8F%E6%A8%A1%E5%BC%8F%E5%AE%8C%E5%85%A8%E8%A7%A3%E6%9E%90-%E4%B8%8B%E7%AF%87/&quot;&gt;Android N App分屏模式完全解析（下）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lowett.com/2016/08/24/android-multiwindow/&quot;&gt;Android-7分屏体验，代码上手初见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>26-Remove Duplicates from Sorted Array</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-26-RemoveDuplicatesFromSortedArray.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-26-RemoveDuplicatesFromSortedArray.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-duplicates-from-sorted-array/&quot;&gt;26. Remove Duplicates from Sorted Array&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;
&lt;p&gt;Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.&lt;/p&gt;

&lt;p&gt;Do not allocate extra space for another array, you must do this in place with constant memory.&lt;/p&gt;

&lt;p&gt;For example,&lt;br /&gt;
Given input array nums =&lt;code class=&quot;highlighter-rouge&quot;&gt; [1,1,2]&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;Your function should return length = &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;, with the first two elements of nums being 1 and 2 respectively. It doesn’t matter what you leave beyond the new length.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个排好序的数组，移除重复的元素，然后返回新的数组长度。&lt;br /&gt;
要求不能额外一个数组大小的空间来实现，要求使用空间实现，&lt;br /&gt;
比如：输入数组=&lt;code class=&quot;highlighter-rouge&quot;&gt; [1,1,2]&lt;/code&gt;,&lt;br /&gt;
你的方法将返回长度为=&lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;，两个元素分别是1和2。这个方法并不关心新长度。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;首先这是一个已经排好序的数组，又要求不能额外的分配一个数组空间来实现。&lt;br /&gt;
所以我们可以利用遍历一遍数组来实现。利用前后两个索引值i,j分别向后移动来&lt;br /&gt;
实现去重有序数组的大小。&lt;br /&gt;
时间复杂度为O(n)&lt;br /&gt;
空间复杂度为O(2)&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by yumodev on 9/18/16.
 */
public class RemoveDuplicates_26 {

    public static int removeDuplicates(int[] nums){
        if (nums == null){
            return 0;
        }

        if (nums.length &amp;lt;= 1){
            return 1;
        }

        int i = 0, j = 1;
        while (i &amp;lt;nums.length &amp;amp;&amp;amp; j &amp;lt; nums.length){
            if (nums[i] == nums[j]){
                j++;
            }else{
                nums[++i] = nums[j];
                j++;
            }
        }

        return i+1;
    }

    public static void main(String[] args){
        int[] nums = {2,7,11,15};
        long startTime = System.nanoTime();
        int result = removeDuplicates(nums);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot; removeDuplicates:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>23-Swap Nodes in Pairs</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-24-SwapNodesInPairs.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-24-SwapNodesInPairs.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/swap-nodes-in-pairs/&quot;&gt;24. Swap Nodes in Pairs&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a linked list, swap every two adjacent nodes and return its head.&lt;/p&gt;

&lt;p&gt;For example,&lt;br /&gt;
Given &lt;code class=&quot;highlighter-rouge&quot;&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4,&lt;/code&gt; you should return the list as &lt;code class=&quot;highlighter-rouge&quot;&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个链表，交互相邻的两个节点，并返回链表的头部。&lt;br /&gt;
比如：给定链表&lt;code class=&quot;highlighter-rouge&quot;&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4,&lt;/code&gt; 应该返回&lt;code class=&quot;highlighter-rouge&quot;&gt;2-&amp;gt;1-&amp;gt;4-&amp;gt;3&lt;/code&gt;&lt;br /&gt;
应当使用常量空间时间，不能修改节点的值，但是可以修改节点本身。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这道题目有两个限定条件：&lt;br /&gt;
1、使用常量空间实现；2、不能修改节点的值。&lt;br /&gt;
所以声明一个节点为ln(0),其next指向head, temp节点为临时节点。&lt;br /&gt;
ln.next表示第一个节点，ln.next.next 标识第二个节点。&lt;br /&gt;
现在需要的工作就是讲ln.next, ln.next.next 交互位置。&lt;br /&gt;
通过下面方法来实现ln.next 和 ln.next.next 位置的呼唤。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;      temp = ln.next;
      ln.next = ln.next.next;
      temp.next = ln.next.next;
      ln.next.next = temp;     
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;时间复杂度为O(n),&lt;br /&gt;
  空间夫再度为O(2);&lt;br /&gt;
### 代码示例-Java&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by yumodev on 9/13/16.
 */
public class SwapPairs_24 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode swapPairs(ListNode head) {
        if (head == null || head.next == null){
            return head;
        }

        int n = 1;

        ListNode ln = new ListNode(0);
        ln.next = head;
        head = head.next;
        ListNode temp;
        while (true){
            if (n % 2 == 0){
                temp = ln.next;
                ln.next = ln.next.next;
                temp.next = ln.next.next;
                ln.next.next = temp;
                ln = ln.next.next;
            }

            if (ln.next == null || ln.next.next == null){
                break;
            }

            n++;
        }

        return head;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(4321);
        //ListNode l1 = initListNode(321);
        long startTime = System.nanoTime();
        ListNode l2 = swapPairs(l1);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;removeNthFromEnd:&quot; + ListNodeToString(l2) + &quot; time:&quot; + time);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>21-Merge Two Sorted Lists</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-21-MergeTwoSortedLists.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-21-MergeTwoSortedLists.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-sorted-lists/&quot;&gt;21. Merge Two Sorted Lists&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;将两个有序链表合并成一个新的链表。新的链表应该有由这两个链表的头部拼接而成。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;按照题意新链表有这两个有序链表的头部拼接而成，所以需要先找到比较两个链表的头部，&lt;br /&gt;
将较小的那个当做新链表的头部，然后同时遍历两个链表进行拼接就行了。&lt;br /&gt;
时间复杂度为:O(m+n)&lt;br /&gt;
空间复杂度为:O(0)&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null ){
            return l2;
        }

        if (l2 == null){
            return l1;
        }

        ListNode ln;
        ListNode head;
        if (l1.val &amp;lt; l2.val){
            head = ln = l1;
            l1 = l1.next;
        }else{
            head = ln = l2;
            l2 = l2.next;
        }

        while (l1 != null || l2 != null){
            if (l1 == null){
                ln.next = l2;
                break;
            }else if (l2 == null){
                ln.next = l1;
                break;
            }

            if (l1.val &amp;lt; l2.val){
                ln.next = l1;
                ln = ln.next;
                l1 = l1.next;
            }else{
                ln.next = l2;
                ln = ln.next;
                l2 = l2.next;
            }
        }

        return head;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>20-Valid Parentheses</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-20-IsValidParentheses.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-20-IsValidParentheses.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/valid-parentheses/&quot;&gt;20. Valid Parentheses&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’ and ‘]’, determine if the input string is valid.&lt;br /&gt;
The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给一个仅包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[’ 和 ‘]’的字符串，然后判断这个字符串是否是有效的。&lt;br /&gt;
括号必须按照顺序进行闭合，比如”()” 和 “()[]{}” 都是有效的，但是 “(]” 和 “([)]” 不是有效的.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这是一个典型的栈应用的例子。如果是字符’(‘，’[’, ‘{‘, 将其压入栈，如果是’)’,’]’,’}’&lt;br /&gt;
就从栈中取顶部字符，如果栈为空或者不相匹配，那么就可以认定是无效的。&lt;br /&gt;
如果和栈顶元素匹配，就继续遍历字符串判定。&lt;br /&gt;
时间复杂度：O(n)&lt;br /&gt;
空间复杂度：O(2)&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码示例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static boolean isValid(String s) {
        if (s == null ||s.length() &amp;lt;= 1){
            return false;
        }

        Stack&amp;lt;Character&amp;gt; stack = new Stack&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;= s.length()-1;i++){
            Character ch = s.charAt(i);
            if (ch == &#39;(&#39; || ch == &#39;[&#39; || ch == &#39;{&#39;){
                stack.push(ch);
            }else{
                if (stack.size() == 0){
                    return false;
                }

                Character sch = stack.pop();

                if (ch == &#39;)&#39;){
                    if (sch != &#39;(&#39;){
                        return false;
                    }
                }else if (ch == &#39;]&#39;){
                    if (sch != &#39;[&#39;){
                        return false;
                    }
                }else if (ch == &#39;}&#39;){
                    if (sch != &#39;{&#39;){
                        return false;
                    }
                }
            }
        }
        return stack.size() == 0;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>19-Remove Nth Node From End of List</title>
        <link>http://disheng54.github.io/2016/09/18/leetcode-19-RemoveNthFromEnd.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/18/leetcode-19-RemoveNthFromEnd.html</guid>
        <pubDate>Sun, 18 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/remove-nth-node-from-end-of-list/&quot;&gt;19. Remove Nth Node From End of List&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a linked list, remove the nth node from the end of list and return its head.&lt;br /&gt;
For example,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Given linked list: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, and n = 2.
   After removing the second node from the end, the linked list becomes 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/code&gt;&lt;br /&gt;
Note:&lt;br /&gt;
Given n will always be valid.&lt;br /&gt;
Try to do this in one pass.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给定一个链表，删除倒数第n个节点，然后返回这链表的头部。&lt;br /&gt;
比如：&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;给定链表： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5,  n = 2.
  从尾部移除第2个节点, 然后链表变为： 1-&amp;gt;2-&amp;gt;3-&amp;gt;5.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注意：给定的n总是有效的，尝试一次通过。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;建立一前一后两个节点:firstLn, secondLn.&lt;br /&gt;
初始化firstLn的next 指向链表头部，secondLn指向链表头部&lt;br /&gt;
先将firstLn移动n个位置，然后开始移动SecondLn节点。&lt;br /&gt;
当FirstLn移动到链表结尾后，此时需要将SecondLn的下一个节点移除即可。&lt;br /&gt;
时间复杂度为：O(n);&lt;br /&gt;
空间复杂度为：O(1);&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ListNode removeNthFromEnd(ListNode head, int n) {
        if (n == 0 || head == null){
            return head;
        }

        ListNode firstLn = head;
        ListNode secondLn = new ListNode(0);
        int pos = 1;

        while (firstNextLn != null){
            if (pos == n){
                secondNextLn.next = head;
            }else if (pos &amp;gt; n){
                secondNextLn = secondNextLn.next;
            }

            firstNextLn = firstNextLn.next;
            pos++;
        }

        if (secondNextLn != null){
            if (secondNextLn.next.equals(head)){
                return head.next;
            }else{
                secondNextLn.next = secondNextLn.next.next;
            }

        }


        return head;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>14-Longest Common Prefix</title>
        <link>http://disheng54.github.io/2016/09/12/leetcode-14-LongestCommonPrefix.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/12/leetcode-14-LongestCommonPrefix.html</guid>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-common-prefix/&quot;&gt;14. Longest Common Prefix&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Write a function to find the longest common prefix string amongst an array of strings.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;编写一个方法来查找一个字符串数组中最长的公共前缀字符串。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道题目的意思是求取所有字符串的最长前缀公共字符串。采用暴力比较的方法是最简单。&lt;br /&gt;
就是循环获取第一个字符串的前缀子串，将这个子串分别和其他字符串的相同索引的子串进行比较，&lt;br /&gt;
如果任意一个其他字符串的前缀子串和第一字符串的前缀子串不相符，那么除去这个前缀子串的最后一个字符，就是最大的公共前缀子串&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by yumodev on 9/12/16.
 */
public class LongestCommonPrefix_14 {
    public static String longestCommonPrefix(String[] strs) {
        if (strs == null || strs.length == 0){
            return &quot;&quot;;
        }


        for (int i = 0; i &amp;lt; strs[0].length(); i++){
            for (int j = 1; j &amp;lt; strs.length; j++){
                if (strs[j].length() &amp;lt;= i || strs[j].charAt(i) != strs[0].charAt(i)){
                    return strs[0].substring(0, i);
                }
            }
        }

        return strs[0];
    }

    public static void main(String[] args) {
        String[] str = {&quot;121&quot;, &quot;12&quot;, &quot;21&quot;};
        long startTime = System.nanoTime();
        String result = longestCommonPrefix(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;longestCommonPrefix:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>13-Roman to Integer</title>
        <link>http://disheng54.github.io/2016/09/12/leetcode-13-RomanToInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/09/12/leetcode-13-RomanToInteger.html</guid>
        <pubDate>Mon, 12 Sep 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/roman-to-integer/&quot;&gt;13. Roman to Integer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a roman numeral, convert it to an integer.&lt;br /&gt;
Input is guaranteed to be within the range from 1 to 3999.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;将给定的一个罗马数字字符串转换为整数&lt;br /&gt;
假定的输入范围是1到3999.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道里面本身很简单，其实难点在于必须要明白罗马数字的标识方法。&lt;br /&gt;
罗马数字一共有七个大写字符，分别是：&lt;code class=&quot;highlighter-rouge&quot;&gt;I、V、X、L、C、D、M&lt;/code&gt;。&lt;br /&gt;
下面是罗马字符和整数的对应关系。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;罗马字符&lt;/th&gt;
      &lt;th&gt;整数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;I&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;1000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;罗马字符串的计算规则就是&lt;br /&gt;
1、从左向右一次计算。&lt;br /&gt;
2、如果一个罗马字符对应的整数比它后面的字符对应的整数小，那么就讲后面的字符对应的整数减去它对应的整数。&lt;br /&gt;
如果一个罗马字符对应的整数不小于它后面的字符对应的整数，那么就讲后面的字符对应的整数加上它对应的整数。&lt;br /&gt;
下面是一个罗马字符串和整数的对应计算实例&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;罗马字符串&lt;/th&gt;
      &lt;th&gt;整数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;III&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IV&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VI&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IX&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XI&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IL&lt;/td&gt;
      &lt;td&gt;49&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LX&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IM&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;VM&lt;/td&gt;
      &lt;td&gt;995&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;XM&lt;/td&gt;
      &lt;td&gt;990&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LM&lt;/td&gt;
      &lt;td&gt;950&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CM&lt;/td&gt;
      &lt;td&gt;900&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DM&lt;/td&gt;
      &lt;td&gt;500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MI&lt;/td&gt;
      &lt;td&gt;1001&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MV&lt;/td&gt;
      &lt;td&gt;1005&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MX&lt;/td&gt;
      &lt;td&gt;1010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;ML&lt;/td&gt;
      &lt;td&gt;1050&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MC&lt;/td&gt;
      &lt;td&gt;1100&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MD&lt;/td&gt;
      &lt;td&gt;1500&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;MDCCCLXXXIV&lt;/td&gt;
      &lt;td&gt;1884&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码示例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by yumodev on 9/12/16.
 */
public class RomanToInteger_13 {
    public static int romanToInt(String s) {
        if (s == null || s.length() == 0){
            return 0;
        }

        int result = 0;
        for (int i = 0; i &amp;lt; s.length();i++){
            char ch = s.charAt(i);
            switch (ch){
                case &#39;I&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; s.charAt(i + 1) != &#39;I&#39;){
                        result -= 1;
                    }else{
                        result += 1;
                    }
                    break;
                }
                case &#39;V&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; (s.charAt(i + 1) != &#39;I&#39; &amp;amp;&amp;amp; s.charAt(i + 1) != &#39;V&#39;)){
                        result -= 5;
                    }else{
                        result += 5;
                    }
                    break;
                }
                case &#39;X&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; ( s.charAt(i + 1) == &#39;C&#39; || s.charAt(i + 1) == &#39;L&#39; || s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 10;
                    }else{
                        result += 10;
                    }
                    break;
                }
                case &#39;L&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; ( s.charAt(i + 1) == &#39;C&#39; || s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 50;
                    }else{
                        result += 50;
                    }
                    break;
                }
                case &#39;C&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; (s.charAt(i + 1) == &#39;M&#39; || s.charAt(i + 1) == &#39;D&#39;)){
                        result -= 100;
                    }else{
                        result += 100;
                    }
                    break;
                }
                case &#39;D&#39;:{
                    if (i &amp;lt; s.length() -1  &amp;amp;&amp;amp; s.charAt(i + 1) == &#39;M&#39;){
                        result -= 500;
                    }else{
                        result += 500;
                    }
                    break;
                }
                case &#39;M&#39;:{
                    result += 1000;
                    break;
                }

            }

        }

        return result;
    }

    public static void main(String[] args) {
        String str = &quot;MDCCCLXXXIV&quot;;
        long startTime = System.nanoTime();
        int result = romanToInt(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;romanToInt:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>9-Palindrome Number</title>
        <link>http://disheng54.github.io/2016/08/26/leetcode-9-PalindromeNumber.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/26/leetcode-9-PalindromeNumber.html</guid>
        <pubDate>Fri, 26 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/palindrome-number/&quot;&gt;9. Palindrome Number&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Determine whether an integer is a palindrome. Do this without extra space.&lt;/p&gt;

&lt;p&gt;Some hints:&lt;br /&gt;
Could negative integers be palindromes? (ie, -1)&lt;/p&gt;

&lt;p&gt;If you are thinking of converting the integer to string, note the restriction of using extra space.&lt;/p&gt;

&lt;p&gt;You could also try reversing an integer. However, if you have solved the problem “Reverse Integer”, you know that the reversed integer might overflow. How would you handle such case?&lt;/p&gt;

&lt;p&gt;There is a more generic way of solving this problem.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;在不需要额外空间的情况下，判定一个整数是否是回文字符串。&lt;br /&gt;
一些提示：&lt;br /&gt;
一个负整数是回文字符串吗?(比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt;)&lt;br /&gt;
如果你想把一个整数转换为字符串，需要注意不需要额外的空间的限制。&lt;br /&gt;
也许你会反转整数，如果你已经解决了这道题目”Reverse Integer”, 你就会知道反转字符串也许会发生溢出，然后你该如何处理这种情况呢。&lt;br /&gt;
有一个更加通用的方式来解决这个问题。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;这道题目需要考虑一些特殊的情况，比如负数不认为是一个负数&lt;br /&gt;
判断一个整数 x 是不是回文字符串，那么就把这个整数反转后，判断和 x 是不是相等就可以了。&lt;br /&gt;
题目中整数溢出问题，是不需要考虑的，凡是反转后发生溢出的，那么肯定不是回文串。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/25/16.
 */
public class PalindromeNumber_9 {
    public static  boolean isPalindrome(int x) {
        if (x &amp;lt; 0){
            return false;
        }

        int los = 0;
        int temp = x;

        while (temp &amp;gt; 0){
            los = los * 10 + temp % 10;
            temp = temp / 10;
        }

        return los == x;
    }

    public static void main(String[] args) {
        int number = 121;
        long startTime = System.nanoTime();
        boolean result = isPalindrome(number);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>8-String to Integer</title>
        <link>http://disheng54.github.io/2016/08/25/leetcode-8-StringToInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/25/leetcode-8-StringToInteger.html</guid>
        <pubDate>Thu, 25 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/string-to-integer-atoi/&quot;&gt;8. String to Integer (atoi)&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Implement atoi to convert a string to an integer.&lt;/p&gt;

&lt;p&gt;Hint: Carefully consider all possible input cases. If you want a challenge, please do not see below and ask yourself what are the possible input cases.&lt;/p&gt;

&lt;p&gt;Notes: It is intended for this problem to be specified vaguely (ie, no given input specs). You are responsible to gather all the input requirements up front.&lt;/p&gt;

&lt;p&gt;Requirements for atoi:&lt;br /&gt;
The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.&lt;/p&gt;

&lt;p&gt;The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.&lt;/p&gt;

&lt;p&gt;If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.&lt;/p&gt;

&lt;p&gt;If no valid conversion could be performed, a zero value is returned. If the correct value is out of the range of representable values, INT_MAX (2147483647) or INT_MIN (-2147483648) is returned.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;实现方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;atoi&lt;/code&gt; 将一个字符串转换为整数&lt;br /&gt;
提示：请考虑到所有输入的情况。如果你想要挑战一下自己，就可以不用开下面的注意事项然后问题自己，都有哪些输入情况。&lt;br /&gt;
注意：这道题目的定义是模糊的(没有给输入的限定条件)，你需要自己考虑所有的输入情况。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;atoi &lt;/code&gt; 方法的要求：&lt;br /&gt;
该方法要求忽略字符串开始的空白字符，一直到第一个非空白字符为止。然后从这个字符开始，先判断初始的正负字符，然后选取尽可能多的数字字符，并将它们转换为一个数值。&lt;br /&gt;
也许该字符串的有效数字后面还有一些额外的非数字字符，那么将忽略这些字符。&lt;br /&gt;
如果第一个非空白字符不是数字字符，或者改字符串是个空串，或者只包含空白字符，则不执行转换。&lt;br /&gt;
如果未执行有效的转换，就返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; .如果转换后的数字超出了 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 类型标识数字的的范围，那么返回&lt;code class=&quot;highlighter-rouge&quot;&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这道题目比较简单，正如题目的里面的讲的那样，难点是要考虑到各种的情况。&lt;br /&gt;
1、空字符串、空白字符串、没有有效数字的字符串，返回0&lt;br /&gt;
2、需要去除前面的无效空白字符。&lt;br /&gt;
3、考虑第一个非空字符，如果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt; 标识正值，如果是&lt;code class=&quot;highlighter-rouge&quot;&gt; -&lt;/code&gt; 标识负值。&lt;br /&gt;
4、忽略有效数字字符后面的所有无效字符，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&#39;   -123&amp;amp;456&#39; &lt;/code&gt;转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;-123&lt;/code&gt;&lt;br /&gt;
5、如果转换后的整数值，超过了返回就返回返回&lt;code class=&quot;highlighter-rouge&quot;&gt;INT_MAX (2147483647) 或者 INT_MIN (-2147483648)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/22/16.
 */
public class Atoi_8 {
    public static int myAtoi(String str) {
        if (str == null ||str.trim().length() == 0){
            return  0;
        }

        int index = 0;
        while ((index &amp;lt; str.length()) &amp;amp;&amp;amp; (str.charAt(index) == &#39; &#39;)){
            index ++;

        }

        int sign = 1;
        if (str.charAt(index) == &#39;+&#39;){
            sign = 1;
            index ++;
        }else if (str.charAt(index) == &#39;-&#39;){
            sign = -1;
            index ++;
        }

        long result = 0L;
        for (int i = index; i &amp;lt; str.length(); i++){
           if( str.charAt(i) &amp;gt;=  &#39;0&#39; &amp;amp;&amp;amp; str.charAt(i) &amp;lt;= &#39;9&#39;){
                result = result * 10 + (str.charAt(i) - &#39;0&#39;);
               if (sign == 1){
                   if(result &amp;gt; Integer.MAX_VALUE){
                       result = Integer.MAX_VALUE;
                       break;
                   }
               }else{
                   if (result*sign &amp;lt; Integer.MIN_VALUE){
                       result = Integer.MIN_VALUE;
                       break;
                   }
               }
           }else{
               break;
           }
        }

        return (int)result * sign;
    }

    public static void main(String[] args) {
        //String str = &quot;  -214748364734dd&quot;;
        String str = &quot;  -00134&quot;;
        long startTime = System.nanoTime();
        int result = myAtoi(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>7-Reverse Integer</title>
        <link>http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/17/leetcode-7-ReserseInteger.html</guid>
        <pubDate>Wed, 17 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-integer/&quot;&gt;7. Reverse Integer&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Reverse digits of an integer.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Have you thought about this?&lt;br /&gt;
Here are some good questions to ask before coding. Bonus points for you if you have already thought through this!&lt;/p&gt;

&lt;p&gt;If the integer’s last digit is 0, what should the output be? ie, cases such as 10, 100.&lt;/p&gt;

&lt;p&gt;Did you notice that the reversed integer might overflow? Assume the input is a 32-bit integer, then the reverse of 1000000003 overflows. How should you handle such cases?&lt;/p&gt;

&lt;p&gt;For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;反转一个整数数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Example1: x = 123, return 321
Example2: x = -123, return -321
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：在编码之前有一些问题需要考虑，如果你已经考虑了这些问题，这将是你的加分点。&lt;br /&gt;
如果该整数的最后一位是0，那么僵该输出什么呢？比如 10， 100&lt;br /&gt;
反转后的整数也许会产生溢出，假定输入的是一个32位的整数，如果反转&lt;code class=&quot;highlighter-rouge&quot;&gt;1000000003&lt;/code&gt;将产生溢出，那这种情况该如何处理呢？&lt;br /&gt;
如果发生了溢出，就直接返回为0.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;需要考虑三个方面的问题。&lt;br /&gt;
1. 需要考虑负数的反转。&lt;br /&gt;
2. 如果整数的末尾是0，比如10， 100， 那么反转后为1， 1&lt;br /&gt;
3. 如果反转后产生了溢出，那么就直接返回 0&lt;/p&gt;

&lt;p&gt;解决思路为：&lt;br /&gt;
定义一个long 类型的变量result，来存储反转后的整数&lt;br /&gt;
然后循环反转,注意负数的问题，同时检测到发生了溢出，就返回0&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/17/16.
 * 反正整形字符串
 */
public class ReverseInteger_7 {
    public static int reverse(int x) {
        long result = 0;
        while (x != 0){
            result = result * 10 + x % 10;
            x = x / 10;

            if (result &amp;gt; Integer.MAX_VALUE || result &amp;lt; Integer.MIN_VALUE){
                result = 0;
                break;
            }
        }

        return (int)result;
    }

    public static void main(String[] args) {
        int x  = 1000000003;
        long startTime = System.nanoTime();
        int result = reverse(x);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;reverse:&quot; + result + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>6-ZigZag Conversion</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-6-ZigZag.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/zigzag-conversion/&quot;&gt;6. ZigZag Conversion&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;The string &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And then read line by line: &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;br /&gt;
Write the code that will take a string and make this conversion given a number of rows:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;string convert(string text, int nRows);&lt;/code&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; should return &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;.&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;将字符串&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAYPALISHIRING&quot;&lt;/code&gt;按照给定的行数，转为成锯齿形的字符串。然后将该锯齿形字符串一次读成&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编写代码将给定的字符串和行数，将字符串进行锯齿转换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string convert(string text, int nRows);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;convert(&quot;PAYPALISHIRING&quot;, 3)&lt;/code&gt; 返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;PAHNAPLSIIGYIR&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解题思路&lt;/h3&gt;

&lt;p&gt;如果nRows = 1， 那么直接返回。&lt;br /&gt;
如果nRows = 2, 转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PYAIHRNAPLSIIG&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P	 Y	 A	 I	 H	 R	 N
A	 P	 L	 S	 I	 I	 G
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果 nRows = 3  转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PAHNAPLSIIGYIR&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 		A		H		N
A 	P 	L	S	I	I	G
Y		I		R	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果 nRows = 4 转换字符串为：&lt;code class=&quot;highlighter-rouge&quot;&gt;PINALSIGYAHRPI&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;P 			I			N
A		L	S		I	G
Y	A		H	R
P			I
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过上面可以总结出一个规律，第一行和最后一行两个数据的间距为: &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * nRows -2 &lt;/code&gt;&lt;br /&gt;
中间第 i 行，第1列和它临近字符的间距为: &lt;code class=&quot;highlighter-rouge&quot;&gt;2*nRows -2 - 2 * i&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/16/16.
 */
public class ZigZag_6 {

    public static String convert(String s, int numRows){
        if (numRows &amp;lt;= 1 || s == null || s.length() == 0){
            return s;
        }

        StringBuilder sb = new StringBuilder();
        int size = 2 * numRows -2;
        for (int i = 0; i &amp;lt; numRows; i++){
            for (int j = i; j &amp;lt; s.length();j+= size){
                sb.append(s.charAt(j));
                if (i != 0 &amp;amp;&amp;amp; i != numRows -1){
                    int temp = j + size - 2 * i;
                    if (temp &amp;lt; s.length()){
                        sb.append(s.charAt(temp));
                    }
                }
            }
        }

        return sb.toString();
    }

    public static void main(String[] args) {
       // String str = &quot;PAYPALISHIRING&quot;;
        String str = &quot;A&quot;;
        int nRows = 1;
        long startTime = System.nanoTime();
        String zigZag = convert(str, nRows);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;ZigZag:&quot; + zigZag + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>5-Longest Palindromic Substring</title>
        <link>http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/16/leetcode-5-LongestPalindrome.html</guid>
        <pubDate>Tue, 16 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindromic-substring/&quot;&gt;Longest Palindromic Substring&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;给定一个字符串 S，找出其中最长的回文子串。假定 S的最长长度为1000，且存在唯一的最长回文子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这个题目可以利用动态规划的方法进行处理。&lt;br /&gt;
假定字符串的长度为len, 声明一个二维数组：dp = new boolean[len][len]&lt;br /&gt;
dp[i][j] 标识字符串S 中S[i~j]的子串是不是回文字符串。&lt;br /&gt;
判断S[i~j]如果是回文串，必须满足两个条件：&lt;br /&gt;
1. S[i] = S[j] &lt;br /&gt;
2. dp[i+1][j-1] = true。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wks on 8/8/16.
 */
public class LongestPalindrome_5 {
    /**
     * 利用动态规划的方法.
     * @param s
     * @return
     */
    public static String longestPalindrome(String s){
        if (s == null || s.length() == 1) {
            return s;
        }

        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int begin = 0, end = 0, max = 1;

        for (int i = len - 1; i &amp;gt;= 0; i--){
            for (int j = i; j &amp;lt; len; j++){
                if (s.charAt(i) == s.charAt(j)){
                    if (j - i &amp;lt;= 2 ||  (dp[i+1][j-1] &amp;amp;&amp;amp; j-1 &amp;gt; 0)){
                        dp[i][j] = true;
                        if (max &amp;lt; j - i + 1){
                            max = j - i + 1;
                            begin = i;
                            end = j;
                        }
                    }
                }
            }
        }


        return s.substring(begin, end+1);
    }

    public static void main(String[] args) {
        String str = &quot;1aba12&quot;;
        long startTime = System.nanoTime();
        String palindrome = longestPalindrome(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;

        System.out.println(&quot;palindrome:&quot; + palindrome + &quot; time:&quot; + time);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>4-Median of Two Sorted Arrays</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-4-MedianSortedArrays.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/median-of-two-sorted-arrays/&quot;&gt;Median of Two Sorted Arrays&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;There are two sorted arrays nums1 and nums2 of size m and n respectively.&lt;br /&gt;
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).&lt;/p&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The median is 2.0&lt;br /&gt;
Example 2:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The median is (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;有两个排序且长度分别为m和n的数组nums1 和 nums2。找出这两个排序的中间值。&lt;br /&gt;
要求运行时间为O(log(m+n))&lt;/p&gt;

&lt;p&gt;示例1:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 3]
nums2 = [2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中位值为： 2.0&lt;br /&gt;
示例2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nums1 = [1, 2]
nums2 = [3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中位值： (2 + 3)/2 = 2.5&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;题目的意思是将两个数组合并后，如果是奇数个，就返回中间的那个值，如果是偶数个，就返回中间两个数的平均值&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;合并的解决的方式&lt;/p&gt;

    &lt;p&gt;首先想到的时候合并的方式解决，其原理就是合并两个数组，算出中位值，其运行时间为O((m+n)/2) .&lt;br /&gt;
 但是不能满足题目运行时间要求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;递归方式解决&lt;/p&gt;

    &lt;p&gt;这种方式是在讨论区发现的。具体实现的原理：寻找数组中第 k(k=（m+n）/ 2+1)个最小的数字.&lt;br /&gt;
 将nums1[k] 和 nums2[k] 进行比较，会有三种情况：&lt;br /&gt;
 如果nums1[k] == nums2[k] 那么这个值就是要找的值。&lt;br /&gt;
 如果nums1[k] &amp;lt; nums2[k],那么第k个数值，必定出现在nums1[ (k+1) ~ m ] 和 nums2[ 0 ~ (k - 1)] 区间中&lt;br /&gt;
 如果nums1[k] &amp;gt; nums2[k],那么第k个数值，必定出现在nums1[ 0 ~ (k - 1)] 和 nums2[ (k+1) ~ n ] 区间中&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

/**
 * Created by yumodev on 8/7/16.
 */
public class MedianTwoSortedArrays_4 {

    /**
     * 通过合并的方式进行字符串处理.
     */
    public static double findMedianSortedArraysByMerge(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;
        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        int num = 0, firstNum = 0;
        int n1 = 0, n2 = 0, index = 1;
        while (true){
            if (n1 &amp;lt; nums1.length){
                if (n2 &amp;lt; nums2.length){
                    if(nums1[n1] &amp;gt; nums2[n2]){
                        num = nums2[n2++];
                    }else{
                        num = nums1[n1++];
                    }
                }else{
                    num = nums1[n1++];
                }
            }else{
                num = nums2[n2++];
            }

            if (index == leftMedian &amp;amp;&amp;amp; rightMedian == leftMedian){
                return num;
            }else if (index == leftMedian &amp;amp;&amp;amp; rightMedian != leftMedian){
                firstNum = num;
            }else if (index == rightMedian){
                return (firstNum + num)/2.0;
            }

            index++;
        }
    }

    /**
     * 通过递归的方式实现.
     * @param nums1
     * @param nums2
     * @return
     */
    public static double findMedianSortedArraysByRecursive(int[] nums1, int[] nums2) {
        if (nums1.length == 0 &amp;amp;&amp;amp; nums2.length == 0) return 0;
        int leftMedian = (nums1.length+nums2.length+1)/2;
        int rightMedian = (nums1.length+nums2.length+2)/2;

        if (nums1.length == 0){
            return (nums2[leftMedian - 1]+ nums2[rightMedian - 1]) / 2.0;
        }else if(nums2.length == 0){
            return (nums1[leftMedian - 1]+ nums1[rightMedian - 1]) / 2.0;
        }

        if (rightMedian != leftMedian){
            return (getMedianNum(nums1,0,nums2,0,leftMedian)+ getMedianNum(nums1,0,nums2,0,rightMedian))/2.0;
        }else{
            return getMedianNum(nums1,0,nums2,0,leftMedian);
        }
    }

    public static double getMedianNum(int[] nums1, int start1, int[]nums2, int start2, int index){
        if(start1 &amp;gt; nums1.length-1) return nums2[start2+index-1];
        if(start2 &amp;gt; nums2.length-1) return nums1[start1+index-1];
        if(index == 1) return Math.min(nums1[start1],nums2[start2]);

        if(start2+index/2-1 &amp;gt; nums2.length-1){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        } 
        if(start1+index/2-1 &amp;gt; nums1.length-1){
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        } 

        if(nums1[start1+index/2-1] &amp;lt; nums2[start2+index/2-1]){
            return getMedianNum(nums1,start1+index/2,nums2,start2,index-index/2);
        }else{
            return getMedianNum(nums1,start1,nums2,start2+index/2,index-index/2);
        }
    }

    public static void main(String[] args){
        int[] nums1 = {1,3};
        int[] nums2 = {2};

//        int[] nums1 = {1,3};
//        int[] nums2 = {2};
        long startTime = System.nanoTime();
        double median = findMedianSortedArraysByMerge(nums1, nums2);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
        
        startTime = System.nanoTime();
        median = findMedianSortedArraysByRecursive(nums1, nums2);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(&quot; median:&quot;+median +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>3-Longest Substring Without Repeating Characters</title>
        <link>http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/07/leetcode-3-engthOfLongestSubstringByMap.html</guid>
        <pubDate>Sun, 07 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/&quot;&gt;Longest Substring Without Repeating Characters&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;Given a string, find the length of the longest substring without repeating characters.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abcabcbb&quot;&lt;/code&gt;, the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abc&quot;&lt;/code&gt;, which the length is 3.&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;bbbbb&quot;,&lt;/code&gt; the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;b&quot;&lt;/code&gt;, with the length of 1.&lt;/p&gt;

&lt;p&gt;Given &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwwkew&quot;&lt;/code&gt;, the answer is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;wke&quot;&lt;/code&gt;, with the length of 3. Note that the answer must be a substring, &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwke&quot;&lt;/code&gt; is a subsequence and not a substring.&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;题目翻译&lt;/h3&gt;

&lt;p&gt;获取一个字符串的各个字符都不相同的子串的最大长度。&lt;br /&gt;
举例：&lt;/p&gt;

&lt;p&gt;字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abcabcbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;abc&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;bbbbb&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;b&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;.&lt;br /&gt;
字符串 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwwkew&quot;&lt;/code&gt;, 符合结果的字串为 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;wke&quot;&lt;/code&gt;, 其长度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;. &lt;br /&gt;
注意结果必须为连续的子串， 其中&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;pwke&quot;&lt;/code&gt;是不同的字符组合，但不是连续的子串&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;首先要明白这道题目是要获取字符串中不同字符字符组成的子串的最大长度，而不是不同字符的个数。&lt;br /&gt;
声明一个变量start,记录不同字符串的初始索引，一个变量mxlen 记录最大程度，然后遍历字串中字符，记录该字符的索引index，并且查询该字符上次出现的索引位置，如果该字符存在上次索引LastIndex，并且该索引值不小于 start，那么将index 减去 start当做该不同字符子串的长度与maxlen，比较取其大着。通过将LastIndex赋值与start。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.airthmetic.leetcode;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by yumo on 8/6/16.
 * 获取字符串中不重复的字字符串的最大长度.
 */
public class LongSubNoRepeatCHar_3 {

    public static int lengthOfLongestSubstringByMap(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            if (map.get(s.charAt(i)) != null){
                int j = map.get(s.charAt(i));
                if (j &amp;gt;= start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = j + 1;
                    map.remove(s.charAt(i));
                }
            }

            map.put(s.charAt(i), i);
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static int lengthOfLongestSubstringByArray(String s) {
        if (s == null || s.isEmpty()){
            return 0;
        }

        int[] chars = new int[256];
        int maxLen = 1;
        int start = 0;

        for (int i = 0; i &amp;lt; s.length(); i++){
            int ch = s.charAt(i);
            if (chars[ch] != 0){
                if (chars[ch] &amp;gt; start){
                    maxLen = (i - start &amp;gt; maxLen) ? i - start : maxLen;
                    start = chars[ch];
                }
            }

            chars[ch] = i + 1;
        }

        return (s.length() - start &amp;gt; maxLen) ? s.length() - start : maxLen;
    }

    public static void main(String[] args){
        //String str = &quot;abcabcbb&quot;;
        //String str = &quot;aaa&quot;;
        //String str = &quot;pwwkew&quot;;
        // String str = &quot;au&quot;;
        String str = &quot;aab&quot;;
        long startTime = System.nanoTime();
        int length = lengthOfLongestSubstringByMap(str);
        long endTime = System.nanoTime();
        long time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);

        startTime = System.nanoTime();
        length = lengthOfLongestSubstringByArray(str);
        endTime = System.nanoTime();
        time = endTime - startTime;
        System.out.println(str+&quot; len:&quot;+length +&quot; time:&quot;+ time);
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by yumodev on 8/6/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() == 0) {
            return 0;
        }

        int chars[128];
        memset(chars, 0xff, 128 * sizeof(int));
        int maxLen = 1;
        int start = 0;
        for (int i = 0; i &amp;lt; s.size(); ++i) {
            if (chars[s[i]] != 0 &amp;amp;&amp;amp; chars[s[i]] &amp;gt; start) {
//                if(i - start &amp;gt; maxLen){
//                    maxLen = i - start;
//                }

                maxLen = i - start &amp;gt; maxLen ? i - start : maxLen;
                start = chars[s[i]];
            }

            chars[s[i]] = i + 1;
        }

        if (s.length() - start &amp;gt; maxLen) {
            maxLen = s.length() - start;
        }

        return maxLen;
    }
};

int main() {
   // string str = &quot;auu&quot;;
    string str = &quot;dvdf&quot;;
    //string str = &quot;aaa&quot;;
    //string str = &quot;pwwkew&quot;;
    // string str = &quot;au&quot;;
    //string str = &quot;aab&quot;;
    clock_t start, finish;
    Solution su;
    start = clock();
    int len = su.lengthOfLongestSubstring(str);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot;&amp;lt;&amp;lt;((double)(finish - start)/CLOCKS_PER_SEC)* 1000000 &amp;lt;&amp;lt;&quot;  len &quot; &amp;lt;&amp;lt;len&amp;lt;&amp;lt;endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-javascript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
  if (s === undefined || s.length === 0) {
   return 0;
 }
 var chars = {};
 var maxLen = 1;
 var start = 0;
 for(i = 0; i &amp;lt; s.length; i++){
   if (chars[s[i]] !== undefined) {
      if (chars[s[i]] &amp;gt;= start) {
        if(i - start &amp;gt; maxLen){
          maxLen = i - start;
        }
        start = chars[s[i]];
      }
   }

   chars[s[i]] = i + 1;
 }

 if(s.length - start &amp;gt; maxLen){
   maxLen = s.length - start;
 }

 return maxLen;
};
//var str = &quot;auu&quot;;
var str = &quot;dvdf&quot;
var len = lengthOfLongestSubstring(str);
console.log(num+&quot; &quot;+len);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>2-Add Two Numbers</title>
        <link>http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/06/leetcode-2-AddTowNumbers.html</guid>
        <pubDate>Sat, 06 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;题目原地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;原题目&lt;/h3&gt;

&lt;p&gt;You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;

&lt;p&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;翻译&lt;/h3&gt;

&lt;p&gt;给出两个标识非负整数的链表，整数在链表中反向存储且链表中的每个节点只存储一个数字。&lt;br /&gt;
将两个整数链表相加，将结果用链表返回&lt;br /&gt;
输入: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;br /&gt;
输出: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;解决思路&lt;/h3&gt;

&lt;p&gt;这是一个简单的问题，只是稍微注意下两个链表长度不一致就可以了。&lt;/p&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例-Java&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wks on 8/5/16.
 * You are given two linked lists representing two non-negative numbers.
 * The digits are stored in reverse order and each of their nodes contain a single digit.
 * Add the two numbers and return it as a linked list.
 * &amp;lt;p&amp;gt;
 * Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)
 * Output: 7 -&amp;gt; 0 -&amp;gt; 8
 */
public class AddTwoNumbers_2 {

    public static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
        }
    }

    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int lso = 0;
        int sum = 0;
        ListNode ls = null;
        ListNode nextLn = null;
        while (l1 != null || l2 != null || lso != 0) {
            sum = lso;
            if (l1 != null) sum += l1.val;
            if (l2 != null) sum += l2.val;

            lso = sum / 10;
            ListNode temp = new ListNode(sum % 10);
            if (ls == null) nextLn = ls = temp;
            else{
                nextLn.next = temp;
                nextLn = nextLn.next;
            }

            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        return ls;
    }

    public static ListNode initListNode(int num) {
        int mod = 0;
        int temp = num;
        ListNode ln = null;
        ListNode nextLn = null;
        while (temp &amp;gt; 0) {
            mod = temp % 10;
            temp = temp / 10;
            if (ln == null){
                nextLn = ln = new ListNode(mod);
            }else{
                nextLn.next = new ListNode(mod);
                nextLn = nextLn.next;
            }
        }

        return ln;
    }

    public static String ListNodeToString(final ListNode listNode) {
        StringBuilder sb = new StringBuilder();
        ListNode ln = listNode;
        while (ln != null) {
            sb.append(ln.val + &quot; &quot;);
            ln = ln.next;
        }

        return sb.toString();
    }

    public static void main(String[] args) {
        ListNode l1 = initListNode(1027633061);
        ListNode l2 = initListNode(1696698036);
//
//        ListNode l1 = initListNode(342);
//        ListNode l2 = initListNode(465);

//        ListNode l1 = initListNode(5);
//        ListNode l2 = initListNode(5);
        System.out.println(&quot;listNode1 &quot; + ListNodeToString(l1));

        System.out.println(&quot;listNode2 &quot; + ListNodeToString(l2));

        ListNode ls = addTwoNumbers(l1, l2);
        System.out.println(&quot;listNodes &quot; + ListNodeToString(ls));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c&quot;&gt;代码示例-c++&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//
// Created by yumo on 8/5/16.
//
#include &amp;lt;iostream&amp;gt;
using namespace std;

struct ListNode
{
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(NULL) { }
};

class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int lso = 0;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while (true){
            int sum = lso;
            if(l1 != NULL){
                sum += l1-&amp;gt;val;
                l1 = l1-&amp;gt;next;
            }
            if(l2 != NULL){
                sum += l2-&amp;gt;val;
                l2 = l2-&amp;gt;next;
            }
            lso = sum /10;
            ListNode* node = new ListNode(sum %10);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }

            if(l1 == NULL &amp;amp;&amp;amp; l2 == NULL &amp;amp;&amp;amp; lso == 0){
                break;
            }
        }

        return ln;
    }

    ListNode* initListNode(int num){
        int mod = 0;
        int temp = num;
        ListNode* ln = NULL;
        ListNode* nextLn = NULL;
        while(num  &amp;gt; 0){
            mod = num % 10;
            num = num / 10;
            ListNode* node = new ListNode(mod);
            if(ln == NULL){
                nextLn = ln = node;
            }else{
                nextLn-&amp;gt;next = node;
                nextLn = node;
            }
        }
        return ln;
    }

    string listNodeToString(ListNode *ln){
        ListNode* next = ln;
        string sb;
        while(next != NULL){
            int val = next-&amp;gt;val;
            next = next-&amp;gt;next;
            sb += to_string(val)+&quot; &quot;;
        }
        return sb;
    }
};

int main()
{
//     int num1 = 342;
//     int num2 = 465;

//    int num1 = 5;
//    int num2 = 5;

      int num1 = 1027633061;
      int num2 = 1696698036;
     Solution solution;

     ListNode* l1 = solution.initListNode(num1);
     ListNode* l2 = solution.initListNode(num2);

     cout&amp;lt;&amp;lt;&quot;l1 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l1)&amp;lt;&amp;lt;endl;
     cout&amp;lt;&amp;lt;&quot;l2 &quot;&amp;lt;&amp;lt;solution.listNodeToString(l2)&amp;lt;&amp;lt;endl;


    clock_t start, finish;

    start = clock();
    ListNode* ln = solution.addTwoNumbers(l1, l2);
    finish = clock();
    cout &amp;lt;&amp;lt; &quot;time:&quot; &amp;lt;&amp;lt; ((double) (finish - start) / CLOCKS_PER_SEC) * 1000000 &amp;lt;&amp;lt;&quot;result: &quot;&amp;lt;&amp;lt;solution.listNodeToString(ln) &amp;lt;&amp;lt; endl;


    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;javascript&quot;&gt;代码示例-JavaScript&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function ListNode(val) {
     this.val = val;
     this.next = null;
}

function initListNode(num){
   var mod = 0;
   var ln = null;
   var nextLn = null;
   while(num &amp;gt; 0){
      mod = num % 10;
      num = parseInt(num / 10);
      if(ln == null){
        ln = new ListNode(mod);
        nextLn = ln;
      }else{
        nextLn.next = new ListNode(mod);
        nextLn = nextLn.next;
      }
   }

   return ln;
}

function listNodeToString(ln){
  var str =&quot;&quot;;
  var next = ln;
  while(next != null){
    str += next.val+&quot; &quot;;
    next = next.next;
  }
  return str;
}

var addTwoNumbers = function(l1, l2) {
    var los = 0;
    var ln = null;
    var nextLn = null;
    while(true){
      var sum = los;
      if(l1 != null){
        sum += l1.val;
        l1 = l1.next;
      }

      if(l2 != null){
        sum += l2.val;
        l2 = l2.next;
      }
      if(ln == null){
        nextLn = ln = new ListNode(sum % 10);
      }else{
        nextLn.next = new ListNode(sum % 10);
        nextLn = nextLn.next;
      }

      los = parseInt(sum / 10);
      if(l1 == null &amp;amp;&amp;amp; l2 == null &amp;amp;&amp;amp; los == 0){
         break;
      }
    }

    return ln;
};

// var num1 = 342;
// var num2 = 465;

var num1 = 5;
var num2 = 5;

// var num1 = 342;
// var num2 = 465;

var l1 = initListNode(num1);
var l2 = initListNode(num2);
console.log(&quot;l1:&quot;+listNodeToString(l1));
console.log(&quot;l2:&quot;+listNodeToString(l2));
var ln = addTwoNumbers(l1, l2);
console.log(&quot;result:&quot;+listNodeToString(ln));

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
      </item>
    
      <item>
        <title>Ubuntu 安装 Tomcat</title>
        <link>http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/08/03/javaWeb-ubuntu-install-tomcat.html</guid>
        <pubDate>Wed, 03 Aug 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;jdk&quot;&gt;安装JDK&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从官网下载JDK，下载路径 http://download.oracle.com/otn-pub/java/jdk/8u101-b13/jdk-8u101-linux-x64.tar.gz&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;jdk-8u101-linux-x64.tar.gz&lt;/code&gt; 移动到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib&lt;/code&gt; 中， 解压到 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/jvm &lt;/code&gt;目录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir jvm
sudo tar -zxvf jdk-8u101-linux-x64.tar.gz -C /usr/lib/jvm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jre&quot;&gt;配置JRE路径&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;打开环境变量文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo vi ~/.bashrc&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;在文件的末尾添加下面内容&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_101
export JRE_HOME=${JAVA_HOME}/jre  
export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib  
export PATH=${JAVA_HOME}/bin:$PATH  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.bashrc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;jre-1&quot;&gt;测试JRE&lt;/h3&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;java -version&lt;/code&gt;  查看当前的Java路径&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java version &quot;1.8.0_101&quot;
Java(TM) SE Runtime Environment (build 1.8.0_101-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat&quot;&gt;安装tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;下载tomcat 下载地址：http://www-eu.apache.org/dist/tomcat/tomcat-9/v9.0.0.M9/bin/apache-tomcat-9.0.0.M9.zip&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将文件移动到 /usr/local 目录下，解压命名为 tomcat9&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cp apache-tomcat-9.0.0.M9.zip /usr/local
  uzip apache-tomcat-9.0.0.M9.zip
  mv apache-tomcat-9.0.0.M9 tomcat9
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tomcat-1&quot;&gt;启动tomcat&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;开启tomcat9 权限&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo chomd 755 /usr/local/tomcat9/bin/*.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;启动tomcat&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/tomcat9/bin
./startup.sh

Using CATALINA_BASE:   /usr/local/tomcat9
Using CATALINA_HOME:   /usr/local/tomcat9
Using CATALINA_TMPDIR: /usr/local/tomcat9/temp
Using JRE_HOME:        /usr/lib/jvm/jdk1.8.0_101/jre
Using CLASSPATH:       /usr/local/tomcat9/bin/bootstrap.jar:/usr/local/tomcat9/bin/tomcat-juli.jar
Tomcat started.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;测试访问&lt;/h3&gt;

&lt;p&gt;在浏览器中输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080&lt;/code&gt; 访问&lt;/p&gt;

</description>
      </item>
    
      <item>
        <title>比较两个字符串排序后是否相等</title>
        <link>http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2016/07/31/string-StringIsSameAfterSort.html</guid>
        <pubDate>Sun, 31 Jul 2016 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;比较两个字符串排序后是否相等&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决思路&lt;/h3&gt;
&lt;p&gt;首先比较字符串的长度，长度不相等的字符串，即使排序后也是不相等。&lt;br /&gt;
如果两个字符串长度相符，那么有下面两种方法进行比较&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;让两个字符串分别排序后进行比较&lt;/li&gt;
  &lt;li&gt;比较两个字符串中的每个字符的数量是否相等
    &lt;ol&gt;
      &lt;li&gt;将字符和字符的数量当做Map的key和value，然后分别比较。&lt;/li&gt;
      &lt;li&gt;如果字符串是Ascii编码，那么可以将字符的数量直接放到数组进行优化。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java&quot;&gt;代码示例(Java)&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.yumo.java.string.test;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
 * Created by yumo on 7/31/16.
 * 比较两个字符排序后是否相等
 */
public class StringIsSameAfterSort {


    private static String sort(String str){
        char[] chArr = str.toCharArray();
        Arrays.sort(chArr);
        return new String(chArr);
    }

    /**
     * 通过Arrays.sort进行比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByArraysSort(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        return sort(str1).equals(sort(str2));
    }

    private static Map convertMapNums(String str){
        Map&amp;lt;Character, Integer&amp;gt; map= new HashMap&amp;lt;&amp;gt;();
        for (int i = 0; i &amp;lt;  str.length(); i++){
            char c = str.charAt(i);
            if (map.get(c) == null){
                map.put(c,  1);
            }else{
                map.put(c,  map.get(c)+1);
            }
        }

        return map;
    }

    /**
     * 将两个字符串的字符和数量放入Map中.然后比较Map中每个字符数量是否相等
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNums(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        Map&amp;lt;Character, Integer&amp;gt; map1 = convertMapNums(str1);
        Map&amp;lt;Character, Integer&amp;gt; map2 = convertMapNums(str2);

        if (map1.size() != map2.size()){
            return false;
        }

        boolean isSame = true;
        Set&amp;lt;Character&amp;gt; set1 = map1.keySet();
        for (Character ch: set1) {
            if (map1.get(ch) != map2.get(ch)){
                isSame = false;
                break;
            }
        }

        return isSame;
    }


    /**
     * 如果是Ascii编码,那么不同字符的数量最大为256个,所以可以声明一个长度256的数组,将字符的数量放到这个数组中,然后在一一比较
     * @param str1
     * @param str2
     * @return
     */
    public static boolean isStringEqualByCharNumsAscii(String str1, String str2){
        if (str1 == null || str2 == null){
            return false;
        }

        if (str1.length() != str2.length()){
            return false;
        }

        if (str1.length() == str2.length() &amp;amp;&amp;amp; str1.length() == 0){
            return true;
        }

        int[] chArr1 = new int[256];
        for (int i = 0; i &amp;lt; str1.length(); i++){
            char ch = str1.charAt(i);
            chArr1[ch] = chArr1[ch]+1;
        }

        int[] chArr2 = new int[256];
        for (int i = 0; i &amp;lt;str2.length(); i++){
            char ch = str2.charAt(i);
            chArr2[ch] = chArr2[ch]+1;
        }

        boolean isSame = true;
        for (int i = 0; i &amp;lt; 256; i++){
            if (chArr1[i] != chArr2[i]){
                isSame = false;
                break;
            }
        }

        return isSame;
    }

    public static void main(String[] args){
        System.out.println(&quot;testList&quot;);
        String str1=&quot;1234567333&quot;;
        String str2=&quot;7654321333&quot;;

        long startTime = System.nanoTime();
        boolean isSame = isStringEqualByArraysSort(str1, str2);
        long endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByArraysSort: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNums(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNums: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

        startTime = System.nanoTime();
        isSame = isStringEqualByCharNumsAscii(str1, str2);
        endTime = System.nanoTime();
        System.out.println(&quot;isStringEqualByCharNumsAscii: &quot;+isSame+&quot; time:&quot;+(endTime - startTime));

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;效率比较&lt;/h3&gt;

&lt;p&gt;假定这两个字符串的长度为10，那么这三种方法所花费的时间如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isStringEqualByArraysSort: true time:167000
isStringEqualByCharNums: true time:518000
isStringEqualByCharNumsAscii: true time:29000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果能够确定字符串中的字符数量，不是太大的话，优先采用利用数组统计字符数量的方法才是效率最高的。&lt;br /&gt;
不过在工作中直接使用数组排序的解决方式是优先考虑的选择&lt;/p&gt;

</description>
      </item>
    
  </channel>
</rss>