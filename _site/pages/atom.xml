<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>禹墨的博客</title>
    <link>http://disheng54.github.io</link>
    <description>禹墨的博客</description>
    
      <item>
        <title>Git-分支常用命令</title>
        <link>http://disheng54.github.io/2015/05/08/git-git2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/05/08/git-git2.html</guid>
        <pubDate>Fri, 08 May 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;   Git常用命令－分支 &lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;基本分支管理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;     git branch :查看分支
     git branch &amp;lt;分支名字&amp;gt; ：创建分支
     git checkout &amp;lt;另外一个分支名字&amp;gt;： 切换到另外一个分支
     git branch -d &amp;lt;分支名字&amp;gt;：删除一个本地分支
     git branch -D &amp;lt;分支名字&amp;gt;：强制删除一个本地分支
     git branch -a： 查看所有的分支
     git branch -r:查看所有的远程分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基本的远程操作&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;     git remote :查看远程分支名字，默认为origin
     git remote -v :查看远程主机版本信息
     git remote show &amp;lt;主机名&amp;gt;: 查看制定主机名的远程主机详细信息，如果没有制定名字会显示当前的远程主机。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;fetch&quot;&gt;fetch操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;      git fetch &amp;lt;远程主机名&amp;gt;:获取远程主机上所有的提交
      git fetch &amp;lt;远程主机名&amp;gt; &amp;lt;分支名&amp;gt; :获取远程主机上一个分支的提交
      git checkout -b &amp;lt;新分支名字&amp;gt; &amp;lt;远程主机名字&amp;gt;/&amp;lt;远程分支名字&amp;gt;:
                   从远程分支更新到本地并在此基础上生成一个新的分支。
      git merge &amp;lt;远程主机名&amp;gt;/&amp;lt;分支名字&amp;gt; 在当前的本地分支上合并远程分支
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;pull&quot;&gt;pull操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;      git pull &amp;lt;远程主机名&amp;gt;&amp;lt;远程分支名字&amp;gt;:&amp;lt;本地分支&amp;gt; ：取回远程主机一个分支的更新，然后与本地的分支合并
      如果是与本地的当前分支合并可忽略:&amp;lt;本地分支&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;push&quot;&gt;push操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;      git push &amp;lt;远程主机名&amp;gt; &amp;lt;本地分支名字&amp;gt;:&amp;lt;远程分支名字&amp;gt; :将本地分支的内容提交到远程分支上 。
      如果要提交到的远程分支和本地分支有跟踪关系就可省略 :&amp;lt;远程分支名字&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>MAC下eclipse的常用快捷键</title>
        <link>http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/04/08/mac-eclipseshortcut.html</guid>
        <pubDate>Wed, 08 Apr 2015 00:00:00 +0800</pubDate>
        <description>&lt;h2 id=&quot;maceclipse-br&quot;&gt;Mac下Eclipse快捷键大全 &lt;br /&gt;&lt;/h2&gt;

&lt;h3 id=&quot;section&quot;&gt;查找帮助&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;     Shift + Command + L : 打开快捷键列表
     Command ＋ F：打开查找
     Command ＋ K ：在当前页面内搜索选中的关键字。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;页面操作类&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    Command＋W：关闭当前编辑页面
    Command＋Shift＋W：关闭当前所有的编辑页面
    Command＋Option  + 右箭头:后一个编辑页面
    Command + Option + 左箭头:前一个编辑页面
    
    Command + t : 快速显示当前类的结构图
    Option + 回车：显示当前选中资源的属性。
    Command + Option + c:显示函数结构。
    Command＋ E：显示当前可选择页面的列表，仅在右上角显示，可以切换页面。
    Command + Shift + E:显示当前编辑页面的列表窗口，进行管理。
    
    Command＋Shift + P：匹配定位，比如while循环的两个大括号之间的匹配。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;bug&quot;&gt;运行调试修改bug&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    Command＋1：快速修复
    Shift + Command + F11 运行
    Command＋F11 调试
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;编辑相关&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;   Command ＋ Option + 上箭头:复制当前行到上一行。
   Command ＋ Option + 下箭头:复制当前行到下一行。  
   Option + 上箭头: 向上移动当前行。
   Option + 下箭头: 向下移动当前行。      
   Command＋D：删除当前行
   
   Option + Command + R:重命名。
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>android开发中的资源</title>
        <link>http://disheng54.github.io/2015/01/27/android-resource.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/27/android-resource.html</guid>
        <pubDate>Tue, 27 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h1 align=&quot;center&quot;&gt;Android 开发资源&lt;/h1&gt;

&lt;h3 id=&quot;section&quot;&gt;开发网站&lt;/h3&gt;

&lt;h3 id=&quot;section-1&quot;&gt;优秀博客&lt;/h3&gt;

&lt;h3 id=&quot;ndk&quot;&gt;NDK&lt;/h3&gt;
&lt;p&gt;    &lt;a href=&quot;http://blog.csdn.net/shulianghan/article/details/18964835&quot;&gt;NDK从入门到精通 介绍的非常详细&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://blog.csdn.net/column/details/blogjnindk.html&quot;&gt;JNI/NDK开发指南 专栏&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;a href=&quot;http://www.cppblog.com/xkjy3000/category/20738.html&quot;&gt;NDK开发教程 不推荐入门看&lt;/a&gt;&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>反射－一个简单的实例应用</title>
        <link>http://disheng54.github.io/2015/01/05/java-reflect.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-reflect.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;反射就是通过一个类的名字或者实例，才操作它的属性和方法的机制。该机制在android开发中非常有用。因为android开发中很多API里的一些方法没有公开，就需要用反射机制才能使用它。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;class&quot;&gt;什么是Class&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;我定义一个类的时候需要使用Class关机字。比如 Class A｛｝;我们定义了一个名字为A的类对象，那么我们就可以理解为Class 就是类对象A的类型。这个想法有点抽象。
Class类有两个重要的方法。
getName(); 获取这个对象的名字。
forName();这个是静态方法。通过一个类的名字，获取到这个类的类型说明，我也不知道该怎么描述，只要不要理解成一个类对象的实例就行。
newInstance() ;通过这个成员方法可以获得一个类的心的实例。
    
下面我我们看一个列子。给一个类的名字，来打印这个类的所有字段和方法。       
 
	/**
	 * TODO 给定一个类名，打印它的属性，方法等等。
	 * yumo
	 * @param className
	 * void
	 * 2015-1-4
	 */
	public void printClass(String className)
	{
		if(className == null || className.length() &amp;lt;=0) return ;
		
		try {
			//返回与带有给定字符串名的类或接口相关联的 Class 对象。
			Class cls = Class.forName(className);
			//一个字符串的权限。
			String modifiers = Modifier.toString(cls.getModifiers());
			System.out.print(modifiers);
			// 打印类的名字
			System.out.print(cls.getName());
			// 获取它的父类。
			Class superCls = cls.getSuperclass();
			if(superCls != null) System.out.print(&quot; extends &quot; + superCls.getName());
			System.out.println(&quot;{&quot;);
			
			//打印field 成员变量
			Field[] fields = cls.getFields();
			for(Field field:fields)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(field.getModifiers());
				System.out.print(modifiers + &quot; &quot;);
				//打印类型
				System.out.print(field.getType() + &quot; &quot;);
				//打印方法的名字
				System.out.print(field.getName());
				
				System.out.println();
			}
			
			//打印methods 
			Method[] methods = cls.getMethods();
			for(Method method : methods)
			{
				//一个字符串的权限。
				modifiers = Modifier.toString(method.getModifiers() );
				
				System.out.print(modifiers + &quot; &quot;);
				//打印返回类型
				System.out.print(method.getReturnType().getName() + &quot; &quot;);
				//打印方法的名字
				System.out.print(method.getName()+&quot;(&quot;);
				//打印参数
				Class[] parameters = method.getParameterTypes();
				for(int i = 0; i &amp;lt; parameters.length; i++)
				{
					if(i &amp;gt; 0) System.out.print(&quot;,&quot;);
					Class para = parameters[i];
					System.out.print(para.getName());
				}
				
				System.out.println(&quot;)&quot;);
			}
			
			System.out.println(&quot;}&quot;);
			
			
		} catch (ClassNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}
	
当我们用这个语句打印Date类的方法，printClass(&quot;java.util.Date&quot;);
打印的结果如下，它完整的输出一个类的结构。

	publicjava.util.Date extends java.lang.Object{
	public boolean equals(java.lang.Object)
	public java.lang.String toString()
	public int hashCode()
	public java.lang.Object clone()
	public int compareTo(java.util.Date)
	public volatile int compareTo(java.lang.Object)
	public boolean after(java.util.Date)
	public boolean before(java.util.Date)
	public static long parse(java.lang.String)
	public void setTime(long)
	public long getTime()
	public int getYear()
	public int getMonth()
	public int getDate()
	public int getHours()
	public int getMinutes()
	public int getSeconds()
	public static long UTC(int,int,int,int,int,int)
	public void setDate(int)
	public void setMonth(int)
	public void setHours(int)
	public void setMinutes(int)
	public void setSeconds(int)
	public void setYear(int)
	public int getDay()
	public java.lang.String toLocaleString()
	public java.lang.String toGMTString()
	public int getTimezoneOffset()
	public final void wait()
	public final native void wait(long)
	public final void wait(long,int)
	public final native java.lang.Class getClass()
	public final native void notify()
	public final native void notifyAll()
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;通过反射操作一个类的字段。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; 我们定义一个Book类。有两个属性，书名和价格。定义如下。
       /**
	 * yumo
	 * 定义一个用于测试的Book类
	 */
	class Book
	{
		public String name = &quot;&quot;;
		
		public double price = 0.0;
		
		public Book(String name, double price)
		{
			this.name = name;
			this.price = price;
		}
		
		public double getPrice(){
			System.out.println(&quot;getPrice 进入运行了&quot;);
			return price;
		}
		
		public void setPrice(Double price)
		{
			System.out.println(&quot;setPrice 进入运行了&quot;);
			this.price = price;
		}
	}
	
	这里我们先看一个Class的一个方法。
	Field getDeclaredField（String）//给定一个字段名称，获取到该字段的实例。
	Field类是表示一个Class中的一个字段。它主要有三个方法。
	getName(); 获取字段的名称。
	get(Object)；获取制定对象上该字段的值。
	set(Object obj, Object value)  将指定对象变量上此 Field 对象表示的字段设置为指定的新值。
	
	下面就用一个列子来展现它的用法。
	我们首先定义一个Book类的实例，然后通过实例获取到它的类对象clsBook.
	然后通过clsBook的getField(&quot;name&quot;)方法获取到name字段的Field的说明。
	然后调用Field对象的get和set方法对该字段惊醒操作。
	
	Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {
		//获取book对象的，name字段
		Field name = clsBook.getDeclaredField(&quot;name&quot;);
		//获取并打印name的值
		System.out.println(&quot;通过反射获取的书名为：&quot;+name.get(book));
		//修改name的值
		System.out.println(&quot;通过反射获取的将书名修改为：android 开发入门详解&quot;);
		name.set(book, &quot;android 开发入门详解&quot;);
		//输出修改后的name的值
		System.out.println(&quot;通过反射修改后书名为：&quot;+book.name);
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
打印结果如下：

	通过反射获取的书名为：Android高级编程
	通过反射获取的将书名修改为：android 开发入门详解
	通过反射修改后书名为：android 开发入门详解
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;通过反射操作一个类的方法&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;我们可以通过反射机制在运行当中动态的获取一个实例方法，来操纵这个方法。需要用到相关类的方法如下
Class类中的方法
Method getMethod(String name, Class&amp;lt;?&amp;gt;... parameterTypes)   返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。
Method 顾名思义表示的一个类型方法类型。它有两个常用的方法。
getName(); 获取这个方法的名称。
Object	invoke(Object obj, Object... args)  对带有指定参数的指定对象调用由此 Method 对象表示的底层方法。
下面我们通过一个列子，领略一下反射魅力。

       Book book = new Book(&quot;Android高级编程&quot;,74);
	//获取book对象
	Class clsBook = book.getClass();
	try {			
		//通过反射调用方法
		Method getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;现在书的价格为:&quot;+book.getPrice());
		
		Double price = 100.0;
		Class[] argsCls = new Class[1];
		argsCls[0] = price.getClass();
		
		Method setPrice = clsBook.getMethod(&quot;setPrice&quot;, argsCls);
		setPrice.invoke(book, price);
		System.out.println(&quot;通过反射通过反射将书的价格修改:&quot;+price);
		
		getPrice = clsBook.getMethod(&quot;getPrice&quot;,null);
		getPrice.invoke(book);
		System.out.println(&quot;通过反射修改后，书的价格为:&quot;+book.getPrice());
	} catch (SecurityException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (NoSuchFieldException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IllegalArgumentException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IllegalAccessException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (NoSuchMethodException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (InvocationTargetException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
}

打印结果如下：

	现在书的价格为:74.0
	setPrice 进入运行了
	通过反射通过反射将书的价格修改:100.0
	getPrice 进入运行了
	getPrice 进入运行了
	通过反射修改后，书的价格为:100.0
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>java 随机数－常用操作集合。</title>
        <link>http://disheng54.github.io/2015/01/05/java-random.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/05/java-random.html</guid>
        <pubDate>Mon, 05 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;  随机数用的场合非常多，但是使用起来并不复杂，非常的简单。下面就是他的一些列方法的使用
  
    Random random = new Random(100);
	
	//随机生成10个int数字  next()
	System.out.println(&quot;随机生成5个int数字  next()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt());
	}
	
	//生成5个 0到100之间的数字。
	System.out.println(&quot;生成5个 0到100之间的数字。 nextInt(100)&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextInt(100));
	}
	
	//随机生成5个boolean值
	System.out.println(&quot;随机生成5个boolean值 netBoolean&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextBoolean());
	}
	
	//随机生成5个longn值
	System.out.println(&quot;随机生成5个long值 random nextLong()&quot;);
	for(int n =0; n &amp;lt; 10; n++)
	{
		System.out.println(random.nextLong());
	}
	
	//随机生成5个fload值
	System.out.println(&quot;随机生成5个fload值 netFloat&quot;);
	for(int n =0; n &amp;lt;5; n++)
	{
		System.out.println(random.nextFloat()*100);
	}
	
	//随机生成5个double值
	System.out.println(&quot;随机生成5个double值 netDouble&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextDouble()*100);
	}
	
	//随机生成10个Gaussian值
	System.out.println(&quot;随机生成5个张太随机数  nextGaussian()&quot;);
	for(int n =0; n &amp;lt; 5; n++)
	{
		System.out.println(random.nextGaussian()*100);
	}
		
	
	//
	System.out.println(&quot;建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])&quot;);
	
	byte[] bytes= new byte[10];
	random.nextBytes(bytes);
	for(byte bt : bytes)
	{
		System.out.println(bt);
	}
		-1193959466
	-1139614796
	837415749
	-1220615319
	-1429538713
	生成5个 0到100之间的数字。 nextInt(100)
	66
	36
	88
	23
	13
	随机生成5个boolean值 netBoolean
	true
	false
	false
	false
	false
	随机生成5个long值 random nextLong()
	1994076515850003689
	-3505880182545671094
	5294845296780165755
	7666949800837858506
	-9143039415690246354
	1622479998420556049
	5700377594808985065
	234374027031053629
	-7316603517567067640
	3586133391558490009
	随机生成5个fload值 netFloat
	86.28953
	15.13797
	91.9473
	12.135201
	23.321033
	随机生成5个double值 netDouble
	41.3242845037923
	28.672630466619474
	62.46190087763299
	73.14622835577995
	48.603697468545924
	随机生成5个张太随机数  nextGaussian()
	-218.73465232186376
	-139.0458132709607
	-170.60989533724836
	-31.26162845667001
	80.45245617401423
	建立一个字节数组，来接收随机生成的字节。 nextBytes(byte[])
	-48
	-50
	-114
	12
	-58
	123
	-118
	-39
	104
	
	执行上面的代码。我们可以等到如下的结果。
	
	随机生成5个int数字  next()
-3
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>线程基础 -线程的创建与执行</title>
        <link>http://disheng54.github.io/2015/01/03/java-thread1.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/03/java-thread1.html</guid>
        <pubDate>Sat, 03 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;section&quot;&gt;什么是线程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    先在的操作系统基本上都是基于多线程的了，在实际的开发中，多线程是无处不在的。一个java程序运行起来，就默认打开一个主线程。那什么是线程呢。
    线程依附于一个进程，是操作系统可以调度的最小单位。一个进程的中的线程之间共用改进程的内存和公共数据。
    使用多线程可以实现并发编程，提高程序的性能。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;如何创建并执行。一个线程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    创建一个线程可以通过两种方法，但是最后执行都是调用Thread类的start()方法来启动一个线程。 start()会自动调用run() 执行线程的操作。
    
    1、通过扩展一个Thread对象，来创建一个线程。
        /**
	 * yumo
	 * 通过继承Thread  创建一个子线程类。
	 */
	class Thread1 extends Thread{
		//线程启动后自动调用run方法运行
		public void run(){
			System.out.println(&quot;thread1&quot;);
		}
	}
	
	我们可以调用Thread的start()启动一个线程。
	
	 Thread1 thread = new Thread1();
	 thread.start();
	 
	 最后的运行结果为：
	 
	 thread1
	 
    2、 通过继承Runnable接口创建一个线程。
    
	     /**
		 * yumo
		 * 通过继承Runnable接口实现Runnable对象，重写其中的run()方法
		 */
		class Runnable1 implements Runnable {
	
			@Override
			public void run() {
				// TODO Auto-generated method stub
				System.out.println(&quot;runnable1&quot;);
			}
		}
	
          建立并执行该线程。
          
          Thread thread1 = new Thread(new Runnable1());
          thread1.start();
          
          输出结果为：	
          
          runnable1
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>线程基础－手动停止线程</title>
        <link>http://disheng54.github.io/2015/01/02/java-thread2.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-thread2.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;  线程启动后，run()方法运行结束后，就标志着线程结束并正常退出了。可是在一些情况下，比如软件关闭时，需要停止一些尚在运行的进程。手动停止线程有三种方式  
  1、 Thread自带的stop()方法
  2、 建立标志位来停止线程。
  3、 Thread的Interrupts  方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;stop&quot;&gt;利用Stop()方法停止线程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  很不幸该方法已经被弃用了。但是该方法还是 的的确确可以让线程立刻停止的。可是问题就是处在立刻停止上面了。就是Stop()让该线程义无反顾的停止了运行，没有丝毫的犹豫，这就带了很多的问题，让线程里的其他成员和开启线程的类非常的不舒服，比如我希望在任何时候，在线程结束以前都打印一条日志，如果用Stop()方法，就不可能打印那条日志了。如果我们打开一个File，一个Socket，我们希望在线程结束的时候，能够调用一下close方法。这也做不到了。所以还是尽可能的少用Stop()方法吧。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;通过标志位来停止一个线程。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  在我以往的开发工作中，我一向是利用利用标志位来手动的停止一个线程的。它的原理就是在run() 方法里面进行一个条件判断，满足条件就接着运行该线程，否则话就进行一些收尾工作，来停止该线程的运行。下面我建立一个不停的打印自己名字的线程，然后 通过一个标志位来结束这个线程。
     
     class Runnable2 implements Runnable{
	
		//初始设置标志位为false
		private boolean mStop = false;
		
		
		/**
		 *  设置停止标志位为true。在run()方法里检测到这个值以后，就会停止线程的运行了。
		 * yumo
		 * void
		 * 2015-1-3
		 */
		public void Stop(){
			mStop = true;
		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			while(true)
			{
				if(mStop) 
				{
					System.out.println(&quot;检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕&quot;);
					break;
				}
				
				System.out.println( Thread.currentThread().getName());
				
				try {
					//让该线程，睡眠50毫秒
					Thread.sleep(50);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			System.out.println(&quot;线程终于结束了&quot;);
		}
		
	}
		
	在上面我们建立了Runnable2 类继承了Runnable接口。现在我们建立一个线程运行起来。
	
	Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	经过打印结果我们发现这是一个死循环，如果不手动停止该线程，它将会一直运行下去。
	
	下面就是利用标志位停止线程发生威力的时候了。
        Runnable2 runnable =  new Runnable2();
	Thread thread2 = new Thread(runnable, &quot;Runnable2&quot;);
	thread2.start();
	
	try {
		Thread.sleep(2000);
	} catch (InterruptedException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	
	runnable.Stop();
	
	最后的输出结果如下：
		............
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		Runnable2
		检测到标志位改变，要我停止运行。好吧，现在就跳出循环，准备谢幕
		线程终于结束了
	
	最后我们看到线程成功的结束了。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;interrupt-&quot;&gt;利用interrupt() 来中断线程。&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;  单单利用标志位结束一个线程，在某些情况下是非常完美的解决方案，而是线程进行了长时间的睡眠，调用了wait，joint时，就麻烦了，非常有可能进行长时间的阻塞，然后就不能检查标志位来停止一个线程了。关于这点，javaAPI提供一个方法 interrupt(),当线程调用该方法时，如果改线程内部调用了wait,sleep,joint 等等，处于阻塞状态时，就会抛出一个InterruptedException 异常，然后我们就有会在捕获这个异常后进行处理，并判断是否要退出线程，等等。ingerrupt 本身并不能中断一个线程，它能中断的阻塞，修改中断标志位等等。
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>String 与 StringBuilder</title>
        <link>http://disheng54.github.io/2015/01/02/java-stringbuilder.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-stringbuilder.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;h3 id=&quot;string--stringbuilder-&quot;&gt;String 与 StringBuilder 异同&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    我觉得String 和StringBuilder最大的异同点在于。String是final 类，初始化后就不能在发生改变了。而StringBuilder是可以改变的。
&lt;/code&gt;&lt;/pre&gt;
</description>
      </item>
    
      <item>
        <title>String源码阅读分析</title>
        <link>http://disheng54.github.io/2015/01/02/java-string1.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/02/java-string1.html</guid>
        <pubDate>Fri, 02 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;java String类是一个使用频率非常高的类。借助分析String类的源码，有助于更好的了解java中字符串的操作，写出更加有效率的代码。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;string-&quot;&gt;String 定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;   public final class String implements Serializable, Comparable&amp;lt;String&amp;gt;, CharSequence｛｝
   String首先是一个final类，它将不能被继承生成一个子类。String为什么要设置为final类型主要有2个方面的考虑。
   1、处于安全性的考虑.String类是java中一个非常底层的类，和操作系统进行的频繁的交互。如果可以String类可以被继承，用户就可能会重写String类的相关方法，这就提供破坏操作系统提供了机会，降低了java的宣称的安全性。
   2、效率的问题：String被定义为final类，那么它的所有方法都是final的，jvm编译器会内联所有的方法，此举可以让String类的效率使用50%，单凭这点就让人心动不已了。
   
   String类继承了Serializable ,所以String类是可序列化的。
   String类继承了Comparable, 所以String可以在集合里面，直接用sort()排序。
   String类继承实现了CharSequence ,所以String类本质上是一个字符序列。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;string--1&quot;&gt;String 成员变量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;   //定义一个字符数组来存放 String的字符序列。
  private final char[] value;
  // 字符偏移的位置。
  private final int offset;
  //String的字符的个数。可以通过length() 方法返回。
  private final int count;
  //该字符串对应生产的一个哈希值。
  private int hashCode;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;string--2&quot;&gt;String 初始化&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;    String的类的初始化方法非常多，非常的丰富，所以初始化String对象还是很方便的。
    
    //声明一个空字符串
     public String() {
          value = EmptyArray.CHAR;
          offset = 0;
         count = 0;
    }
    
    利用byte[] 生成为字符串。
    //下面几个是利用字节数组转换一个新的String对象。将字节数组解码为字符串的字符集可以制定，也可使使用系统默认
    public String(byte[] data) ;//将一个字节数组生成一个新的字符串。使用默认字符集
    public String(byte[] data, int offset, int byteCount) ；将数组从offset位置后读取byteCount个字节转换为数组。使用默认字符集。
    
    将字节数据转换为从offset位置读取byteCount个字节转换为数组，使用用户指定的字符集，如果不支持该字符集，就抛出UnsupportedEncodingException.
    public String(byte[] data, int offset, int byteCount, String charsetName) throws UnsupportedEncodingException 
    将字节数据转换为从offset位置读取byteCount个字节转换为数组，使用用户指定的字符集，如果不支持该字符集，就抛出UnsupportedEncodingException.
    public String(byte[] data, int offset, int byteCount, Charset charset) ;
    利用用户制定的字符集.将byte数组生成一个新的字符串。
    public String(byte[] data, Charset charset) ;
    
    利用char[] 声明一个字符串。
     public String(char[] data)//将一个char数组声明一个新的String对象。内部调用public String(char[] data, int offset, int charCount)实现
      
      /**
    * 用char数组生命一个新的字符串变量。然后然后修改这个char数组将不再影响新生成的字符串。	    *
    * 当 data为null的时候，报空指针异常。
    * @throws IndexOutOfBoundsException
    *             if {@code charCount &amp;lt; 0 || offset &amp;lt; 0 || offset + charCount &amp;gt; data.length}
    */
   public String(char[] data, int offset, int charCount) {
      //检查是否越界
       if ((offset | charCount) &amp;lt; 0 || charCount &amp;gt; data.length - offset) {
           throw failedBoundsCheck(data.length, offset, charCount);
       }
       this.offset = 0;
       //新生成一个string对象 ，所有新生的char数组和旧的数组没有关联。
       this.value = new char[charCount];
       this.count = charCount;
       System.arraycopy(data, offset, value, 0, count);
   }
   
   /*
     * 直接用char数组生产一个字符串对象。其中char[]没有在new 一个新的数组，所以二者是一个char数组。	     * Does not range check, null check, or copy the character array.
     */
    String(int offset, int charCount, char[] chars) {
        this.value = chars;
        this.offset = offset;
        this.count = charCount;
    }
    
     /**
     * 用一个字符串的副本构造一个新的字符串。
     */
    public String(String toCopy) {
        value = (toCopy.value.length == toCopy.count)
                ? toCopy.value
                : Arrays.copyOfRange(toCopy.value, toCopy.offset, toCopy.offset + toCopy.length());
        offset = 0;
        count = value.length;
    }

     /**
     * 用字符缓冲区的字符序列构建一个字符串。是线程安全的。
     * {@code StringBuffer}.
     */
    public String(StringBuffer stringBuffer) {
        offset = 0;
        synchronized (stringBuffer) {
            value = stringBuffer.shareValue();
            count = stringBuffer.length();
        }
    }

    /**
     * 用int数组构建一个字符串，字符串的序列为unicode字符。	     *
     * @throws NullPointerException
     *             if {@code codePoints == null}.
     * @throws IllegalArgumentException
     *             if any of the elements of {@code codePoints} are not valid
     *             Unicode code points.
     * @throws IndexOutOfBoundsException
     *             if {@code offset} or {@code count} are not within the bounds
     *             of {@code codePoints}.
     * @since 1.5
     */
    public String(int[] codePoints, int offset, int count) {
        if (codePoints == null) {
            throw new NullPointerException(&quot;codePoints == null&quot;);
        }
        if ((offset | count) &amp;lt; 0 || count &amp;gt; codePoints.length - offset) {
            throw failedBoundsCheck(codePoints.length, offset, count);
        }
        this.offset = 0;
        //unicode 字符占用两个字节，int型数据为4个字节。所以要乘以二。
        this.value = new char[count * 2];
        int end = offset + count;
        int c = 0;
        for (int i = offset; i &amp;lt; end; i++) {
            c += Character.toChars(codePoints[i], this.value, c);
        }
        this.count = c;
    }

    /**
     * 构建一个新的string对象，包含字符串生成器的字符序列。
     *
     * @throws NullPointerException
     *             if {@code stringBuilder == null}.
     * @since 1.5
     */
    public String(StringBuilder stringBuilder) {
        if (stringBuilder == null) {
            throw new NullPointerException(&quot;stringBuilder == null&quot;);
        }
        this.offset = 0;
        this.count = stringBuilder.length();
        this.value = new char[this.count];
        stringBuilder.getChars(0, this.count, this.value, 0);
    }
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Git常用操作</title>
        <link>http://disheng54.github.io/2015/01/01/git-git.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/01/git-git.html</guid>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;以前一直使用GitHub的图像客户的来操作自己版本库的提交和更新。现在感觉效率不高，虽下定决心要在命令行下面操作Git。所以我有必要把平时要使用Git命令整理一份文档出来，从而可以更熟练的使用Git。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;基础配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; 查看配置： git config --list 
 设置用户名：git config --global user.name &quot;gitname&quot;
 设置邮箱：git config --global user.email &quot;git@com.cn&quot;
 查看用户名： git config user.name
 查看邮箱： git config user.email
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;获取帮助&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; 查看帮助：git help config
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;初始化一个版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git init：在一个文件目录下面，初始化一个版本库。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-3&quot;&gt;克隆一个服务器版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  git clone https://github.com/disheng54/disheng54.github.io.git  disheng54
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;查看本地状态&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;  git status ;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;把改动暂存起来。&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git add  .     // 将所有改动的文件加入在暂存区
git add 文件名 //将单个改动的文件加入到暂存区
git commit -m &quot;更新说明&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-6&quot;&gt;删除文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git rm 文件名称
git rm --cached 删除一个暂存区文件。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-7&quot;&gt;更新文件的名字&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git mv 旧文件名字 新文件名字
 git commit－m &quot;更新文件名字&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-8&quot;&gt;提交文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git  commit -m &quot;提交说明&quot;
git  commit －a -m &quot;不用先用add文件到缓存，直接提交文件&quot;
git  commit  --amend 重新提交
git  reset HEAD 文件名：  从暂存区中撤消文件。
git  checkout  -- 文件名： 撤消修改
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-9&quot;&gt;忽略一些文件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cat .gitignore
# Built application files
*.apk 
*.ap_

# Files for the Dalvik VM
*.dex

# Java class files
*.class

# Generated files
bin/
gen/

# Gradle files
.gradle/
build/

# Local configuration file (sdk path, etc)
local.properties

# Proguard folder generated by Eclipse
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-10&quot;&gt;查看提交日志&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git log
 git log -p 显示每次的内容差异。
 git log  -2 显示最近的两次更新
 git log --stat 近显示简要的增改行数。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-11&quot;&gt;在本地初始化一个版本库，然后提交到服务器版本&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git init
git add .
git commit -m &quot;first commit&quot;
git remote add origin https://github.com/disheng54/yumoJava.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-12&quot;&gt;远程库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git remote -v ：显示远程库
 git remote show origin :查看远程库信息
 git push origin master :向远程服务器提交数据。
 git remote rm origin :删除远程仓库。
 git remote rename origin origin1 ：重命名远程仓库。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-13&quot;&gt;标签&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git  tag： 显示标签
 git tag -i &quot;tagone&quot;  :显示其中一个标签。
 git  tag  -a v0.1  -m &quot;test tag&quot;:添加一个标签
 git show v0.1:显示刚才天假的标签。
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>Android http开发（－） 下载web页面</title>
        <link>http://disheng54.github.io/2015/01/01/android-http.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2015/01/01/android-http.html</guid>
        <pubDate>Thu, 01 Jan 2015 00:00:00 +0800</pubDate>
        <description>&lt;pre&gt;&lt;code&gt;Android中HTTP协议的开发还是比较重要的，熟练的掌握HTTP开发，有助于开发效率，给用户一个更加优秀的APP产品。Android 中使用HTTP协议开发可以使用java自带的API－HttpURLConnection，也可以使用Apache HttpClient。下面就以这两种方式分别实现对一个web页面的下载。
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;httpurlconnection-&quot;&gt;(-)HttpURLConnection 实现一个页面的下载。&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;   	/**
 * TODO
 * yumo 利用java的HttpConnectionURL 访问一个网站，并获取它的网站数据。
 * @param url 要下载web页面的网址，比如Http://www.baidu.com
 * @return
 * int
 * 2015-1-1
 */
private int getByJavaHttp(String webSite)
{
	int statusCode = -1;
	try {
		//见一个一个URL
		URL url = new URL(webSite);
		//访问web页面
		HttpURLConnection httpConnection = (HttpURLConnection) url.openConnection();
		//获取返回的状态吗。
		statusCode = httpConnection.getResponseCode();
		//获取下砸的web页面数据。
		InputStream inputStream = new BufferedInputStream(httpConnection.getInputStream());
		Reader reader = new InputStreamReader(inputStream);
		String strResult = &quot;&quot;;
		int c;
		while( (c = reader.read()) != -1)
		{
			strResult += String.valueOf((char)c);
		}
		Log.d(TAG,&quot;getByJavaHttp: &quot; + strResult);
	} catch (MalformedURLException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return statusCode ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;apachehttpclient-web&quot;&gt;（二） 通过ApacheHttpClient 实现一个web页面的下载&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;/**
 * TODO
 * yumo 打印网站的数据 利用Apache httpClient
 * @param url 网站名称 比如http://www.baidu.com
 * @return
 * int 返回请求结果
 * 2015-1-1
 */
private int getByApacheHttp(String url) 
{
	int statusCode = -1;
	//建立一个网络请求
	HttpGet httpRequest = new HttpGet(url);
	HttpClient httpClient = new DefaultHttpClient();
	try {
		//执行请求网络。
		HttpResponse httpResponse = httpClient.execute(httpRequest);
		//获取网络状态吗
		statusCode = httpResponse.getStatusLine().getStatusCode(); 
		if( statusCode == HttpStatus.SC_OK)
		{
			//如果成功获取数据则打印日志。
			String strResult = EntityUtils.toString(httpResponse.getEntity());
			Log.d(TAG, &quot;getByAndroidHttp:&quot;+strResult);
		}else
		{
			Log.d(TAG,&quot;getByAndroidHttp errorCode :&quot;+ statusCode);
		}
	} catch (ClientProtocolException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	} catch (IOException e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}
	return statusCode;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>mou 常用快捷键</title>
        <link>http://disheng54.github.io/2014/12/24/mac-moushortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2014/12/24/mac-moushortcut.html</guid>
        <pubDate>Wed, 24 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;显示预览窗口 Toggle live preview: Shift + Cmd + I&lt;/li&gt;
  &lt;li&gt;显示字数 Toggle Words Counter: Shift + Cmd + W&lt;/li&gt;
  &lt;li&gt;将当前窗口设置为透明窗口 Toggle Transparent: Shift + Cmd + T&lt;/li&gt;
  &lt;li&gt;固定当前窗口 Toggle Floating: Shift + Cmd + F&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口相等 Left/Right = 1/1: Cmd + 0&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口的显示比例为 3:1 Left/Right = 3/1: Cmd + +&lt;/li&gt;
  &lt;li&gt;编辑窗口和预览窗口的显示比例为 1:3 Left/Right = 1/3: Cmd + -&lt;/li&gt;
  &lt;li&gt;文字方向 Toggle Writing orientation: Cmd + L&lt;/li&gt;
  &lt;li&gt;全屏显示开关 Toggle fullscreen: Control + Cmd + F&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;actions&quot;&gt;Actions&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Copy HTML: Option + Cmd + C&lt;/li&gt;
  &lt;li&gt;重点显示选中文本 Strong: Select text, Cmd + B&lt;/li&gt;
  &lt;li&gt;将选中文本斜体显示 Emphasize:Select text, Cmd + I&lt;/li&gt;
  &lt;li&gt;Inline Code: Select text, Cmd + K&lt;/li&gt;
  &lt;li&gt;加删除线 Strikethrough: Select text, Cmd + U&lt;/li&gt;
  &lt;li&gt;插入超链接 Link: Select text, Control + Shift + L&lt;/li&gt;
  &lt;li&gt;插入图像 Image: Select text, Control + Shift + I&lt;/li&gt;
  &lt;li&gt;选中当前单词 Select Word: Control + Option + W&lt;/li&gt;
  &lt;li&gt;选中当前行 Select Line: Shift + Cmd + L&lt;/li&gt;
  &lt;li&gt;选中所有 Select All: Cmd + A&lt;/li&gt;
  &lt;li&gt;取消选中所有 Deselect All: Cmd + D&lt;/li&gt;
  &lt;li&gt;将选中文本 转化为大写字母 Convert to Uppercase: Select text, Control + U&lt;/li&gt;
  &lt;li&gt;将选中文本 转化为小写字母 Convert to Lowercase: Select text, Control + Shift + U&lt;/li&gt;
  &lt;li&gt;将选中文本所有单词的首字母转为大写Convert to Titlecase: Select text, Control + Option + U&lt;/li&gt;
  &lt;li&gt;将选中文本插入编号 Convert to List: Select lines, Control + L&lt;/li&gt;
  &lt;li&gt;将选中文本转换成引用块 Convert to Blockquote: Select lines, Control + Q&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为1级标题 Convert to H1: Cmd + 1&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为2级标题 Convert to H2: Cmd + 2&lt;/li&gt;
  &lt;li&gt;将光标所在行转化为3级标题 Convert to H3: Cmd + 3&lt;/li&gt;
  &lt;li&gt;将当前行转化为4级标题 Convert to H4: Cmd + 4&lt;/li&gt;
  &lt;li&gt;将当前行转化为5级标题 Convert to H5: Cmd + 5&lt;/li&gt;
  &lt;li&gt;将当前行转化为6级标题 Convert to H6: Cmd + 6&lt;/li&gt;
  &lt;li&gt;Convert Spaces to Tabs: Control + [&lt;/li&gt;
  &lt;li&gt;Convert Tabs to Spaces: Control + ]&lt;/li&gt;
  &lt;li&gt;插入当前日期 Insert Current Date: Control + Shift + 1&lt;/li&gt;
  &lt;li&gt;插入当前时间 Insert Current Time: Control + Shift + 2&lt;/li&gt;
  &lt;li&gt;插入&amp;lt;符号 Insert entity &amp;lt;: Control + Shift + ,&lt;/li&gt;
  &lt;li&gt;插入&amp;gt;符号 Insert entity &amp;gt;: Control + Shift + .&lt;/li&gt;
  &lt;li&gt;插入$符号 Insert entity &amp;amp;: Control + Shift + 7&lt;/li&gt;
  &lt;li&gt;Insert entity Space: Control + Shift + Space&lt;/li&gt;
  &lt;li&gt;Insert Scriptogr.am Header: Control + Shift + G&lt;/li&gt;
  &lt;li&gt;左缩进 Shift Line Left: Select lines, Cmd + [&lt;/li&gt;
  &lt;li&gt;右缩进 Shift Line Right: Select lines, Cmd + ]&lt;/li&gt;
  &lt;li&gt;插入下一行 New Line: Cmd + Return&lt;/li&gt;
  &lt;li&gt;添加注释 Comment: Cmd + /&lt;/li&gt;
  &lt;li&gt;插入换行符 Hard Linebreak: Control + Return&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;edit&quot;&gt;Edit&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;自动完成单词 Auto complete current word: Escape&lt;/li&gt;
  &lt;li&gt;查找 voiceFind: Cmd + F&lt;/li&gt;
  &lt;li&gt;取消查找框 Close find bar: Esc&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;post&quot;&gt;Post&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Post on Scriptogr.am: Control + Shift + S&lt;/li&gt;
  &lt;li&gt;提交到 Tunblr Post on Tumblr: Control + Shift + T&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;export&quot;&gt;Export&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;导出为HTML格式文件 Export HTML: Option + Cmd + E&lt;/li&gt;
  &lt;li&gt;导出为PDF格式文件 Export PDF:  Option + Cmd + P&lt;/li&gt;
&lt;/ul&gt;
</description>
      </item>
    
      <item>
        <title>mac 常用快捷键</title>
        <link>http://disheng54.github.io/2014/12/10/mac-shortcut.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2014/12/10/mac-shortcut.html</guid>
        <pubDate>Wed, 10 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;h1 id=&quot;mac--br&quot;&gt;mac 常用快捷键 &lt;br /&gt;&lt;/h1&gt;

&lt;h4 id=&quot;section&quot;&gt;文件操作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;   Command＋A   全部选中文件
   Option＋Command＋A 取消全部选中的文件。
   Command＋c   拷贝选中的文件
   Command＋D   复制所选项
   Command＋v   粘贴选中的文件
   Command＋X   剪切选中的文件
   Command＋Z   撤销上一步操作
   Shift+Command+Z 撤销刚才的撤销       
   Command ＋delete  移到废纸篓
   shift ＋Command ＋ delete 清到废纸篓
   Option ＋ shift ＋ Command ＋ delete： 不提示删除废纸篓。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-1&quot;&gt;应用操作&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;   Command + tab 向前切换到上一个窗口
   Shift+Command+tab 向后切换应用
   Command + W   关闭当前窗口
   Option ＋ Command ＋ W 关闭所有的窗口
   Shift +Option + Command +ESC  强制退出当前的应用程序 按住3秒钟
   
   Command ＋ N 复制当前的应用，新生成一个窗口
   Command ＋ M 最小化窗口
   Shift ＋ Command ＋ M  最小化所有窗口
   
   Command + ] 向后
   Command + [ 向前
   
   Command ＋ shift ＋ ？ 打开帮助
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;section-2&quot;&gt;文件编辑&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;   Control ＋ A：移动到段落和行的开始。
   Control ＋ E： 移动到段落和行的结束
   Control ＋ B；向后移动一个字符
   Control ＋ F；向前移动一个字符	   
   Control ＋ D：删除光标前的字符
   Control ＋ H： 删除光标后的字符
   Control ＋ K：删除光标到行或者到断尾的内容
   Control ＋ L：显示在区域位置中间
   Control ＋ N：下移一行
   Control ＋ P：上移一行
   Control ＋ O ： 在光标后插入一行
   Control ＋ T：将光标前后的字好准备。
   Control ＋ V：进入下页。
   
   Control ＋ 方向键 ：聚焦视图内的另外一个值或单元格。
   
   Command + {：使所选内容左对齐
   Command + }:  使所选内容右对齐
   Command + I:使所选内容剧中对齐。
   
   Command＋右箭头：将插入点移到行尾
   Command＋左箭头：将插入点移到行首
   Command＋上箭头：将插入移到文稿开头
   Command＋下箭头：将插入点移到文稿结尾
   
   Shift＋右箭头：将选中文本范围向右扩充一个字符。
   Shift＋左箭头：将选中文本范围向左扩充一个字符。
   Shift + 上箭头：将文件扩充到上一行相同位置。
   Shift + 下箭头：将选中文件扩充至下一行相同位置。
   
   Shift ＋ Command ＋ 右箭头：选中当前点到行尾之间的内容。
   Shift ＋ Command ＋ 左箭头：选中当前点到行首之间的内容。
   Shift ＋ Command ＋ 上箭头：选中当前点到文稿首部的之间的内容。
   Shift ＋ Command ＋ 下箭头：选中当前点到文稿尾部之间的内容。
   
   Shift ＋ Option ＋ 右箭头：将选中文本扩充单当前词的尾部，再按一次，扩充至下一词的尾部。
   Shift ＋ Option ＋ 左箭头：将选中文件扩充至当前词的首部，在按一次，扩充至上一词的首部。
   Shift ＋ Option ＋ 上箭头：将选中文本扩充至当前段落的首部，再按一次，扩充至上一段路的首部。
   Shift ＋ Option ＋ 下箭头：将选中文本扩充至当前段落的尾部，再按一次，扩充至下一段落的尾部。
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;finder&quot;&gt;Finder&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;   shift + Command + A 打开应用程序
   shift + command + D 打开桌面文件夹
   shift + Command + C 打开电脑窗口
   shift + Command + U 打开实用工具
   shift + Command + G 打开前往
   shift + Command + F 打开所有的我的所有文件
   shift + Command + O 打开文稿
   shift + Command + L 下载
   shift + Command + H 个人
   shift + Command + J iCloud Drive
   shift + Command + R AirDrop          
   Command + K 连接服务器
   
   Command + 上箭头 打开所含的文件夹
   Control + Command + 上箭头 新窗口中打开上级文件夹
   
   Command + J 调出显示选项       
   Command ＋ i 查看简介
   空格键 快速查看
   Option ＋ Command ＋ Y ： 以浏览的方式打开
   shift ＋ Command ＋ N 新建文件夹
&lt;/code&gt;&lt;/pre&gt;

</description>
      </item>
    
      <item>
        <title>activity的常见问题</title>
        <link>http://disheng54.github.io/2014/12/10/android-activity.html</link>
        <guid isPermaLink="true">http://disheng54.github.io/2014/12/10/android-activity.html</guid>
        <pubDate>Wed, 10 Dec 2014 00:00:00 +0800</pubDate>
        <description>&lt;p&gt;##1 . 什么是activity？&lt;/p&gt;

&lt;p&gt;##2 . 描述一下activity的声明周期？&lt;/p&gt;

&lt;p&gt;##3 . 如何退出已调用多个activity的app？&lt;/p&gt;

&lt;p&gt;##4 . 后台activity如何在被系统回收之前，保存数据状态？&lt;/p&gt;

&lt;p&gt;##5 . activity在屏幕旋转时的生命周期?&lt;/p&gt;

&lt;p&gt;##6 . activity的四种启动模式?&lt;/p&gt;

&lt;p&gt;##7 . activity和task相关的启动模式有?&lt;/p&gt;

&lt;p&gt;##8 . 两个activity之间跳转必然要执行的方法?&lt;/p&gt;

&lt;p&gt;##9 . 如何将一个activity设置成窗口样式?&lt;/p&gt;

&lt;p&gt;##10 . 如何通过Intent启动一个系统app都有哪些?&lt;/p&gt;

</description>
      </item>
    
  </channel>
</rss>